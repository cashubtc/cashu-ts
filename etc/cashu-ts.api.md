## API Report File for "@cashu/cashu-ts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ApiError = {
    error?: string;
    code?: number;
    detail?: string;
};

// @public
export type BlindingData = {
    blindedMessages: Array<SerializedBlindedMessage>;
    secrets: Array<Uint8Array>;
    blindingFactors: Array<bigint>;
};

// @public
export class CashuMint {
    // Warning: (ae-forgotten-export) The symbol "request" needs to be exported by the entry point index.d.ts
    constructor(_mintUrl: string, _customRequest?: typeof request | undefined);
    static check(mintUrl: string, checkPayload: CheckStatePayload, customRequest?: typeof request): Promise<CheckStateResponse>;
    check(checkPayload: CheckStatePayload): Promise<CheckStateResponse>;
    static checkMeltQuote(mintUrl: string, quote: string, customRequest?: typeof request): Promise<MeltQuoteResponse>;
    checkMeltQuote(quote: string): Promise<MeltQuoteResponse>;
    static checkMintQuote(mintUrl: string, quote: string, customRequest?: typeof request): Promise<MintQuoteResponse>;
    checkMintQuote(quote: string): Promise<MintQuoteResponse>;
    connectWebSocket(): Promise<void>;
    static createMeltQuote(mintUrl: string, meltQuotePayload: MeltQuotePayload, customRequest?: typeof request): Promise<MeltQuoteResponse>;
    createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<MeltQuoteResponse>;
    static createMintQuote(mintUrl: string, mintQuotePayload: MintQuotePayload, customRequest?: typeof request): Promise<MintQuoteResponse>;
    createMintQuote(mintQuotePayload: MintQuotePayload): Promise<MintQuoteResponse>;
    disconnectWebSocket(): void;
    static getInfo(mintUrl: string, customRequest?: typeof request): Promise<GetInfoResponse>;
    getInfo(): Promise<GetInfoResponse>;
    static getKeys(mintUrl: string, keysetId?: string, customRequest?: typeof request): Promise<MintActiveKeys>;
    getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys>;
    static getKeySets(mintUrl: string, customRequest?: typeof request): Promise<MintAllKeysets>;
    getKeySets(): Promise<MintAllKeysets>;
    static melt(mintUrl: string, meltPayload: MeltPayload, customRequest?: typeof request): Promise<MeltQuoteResponse>;
    melt(meltPayload: MeltPayload): Promise<MeltQuoteResponse>;
    static mint(mintUrl: string, mintPayload: MintPayload, customRequest?: typeof request): Promise<MintResponse>;
    mint(mintPayload: MintPayload): Promise<MintResponse>;
    // (undocumented)
    get mintUrl(): string;
    // (undocumented)
    static restore(mintUrl: string, restorePayload: PostRestorePayload, customRequest?: typeof request): Promise<PostRestoreResponse>;
    // (undocumented)
    restore(restorePayload: {
        outputs: Array<SerializedBlindedMessage>;
    }): Promise<PostRestoreResponse>;
    static swap(mintUrl: string, swapPayload: SwapPayload, customRequest?: typeof request): Promise<SwapResponse>;
    swap(swapPayload: SwapPayload): Promise<SwapResponse>;
    // Warning: (ae-forgotten-export) The symbol "WSConnection" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get webSocketConnection(): WSConnection | undefined;
}

// @public
export class CashuWallet {
    constructor(mint: CashuMint, options?: {
        unit?: string;
        keys?: Array<MintKeys> | MintKeys;
        keysets?: Array<MintKeyset>;
        mintInfo?: GetInfoResponse;
        bip39seed?: Uint8Array;
        denominationTarget?: number;
    });
    checkMeltQuote(quote: string): Promise<MeltQuoteResponse>;
    checkMintQuote(quote: string): Promise<MintQuoteResponse>;
    checkProofsStates(proofs: Array<Proof>): Promise<Array<ProofState>>;
    createMeltQuote(invoice: string): Promise<MeltQuoteResponse>;
    createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse>;
    getActiveKeyset(keysets: Array<MintKeyset>): MintKeyset;
    getAllKeys(): Promise<Array<MintKeys>>;
    getFeesForKeyset(nInputs: number, keysetId: string): number;
    getFeesForProofs(proofs: Array<Proof>): number;
    getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys>;
    getKeySets(): Promise<Array<MintKeyset>>;
    getMintInfo(): Promise<MintInfo>;
    // (undocumented)
    get keys(): Map<string, MintKeys>;
    // (undocumented)
    get keysetId(): string;
    set keysetId(keysetId: string);
    // (undocumented)
    get keysets(): Array<MintKeyset>;
    loadMint(): Promise<void>;
    meltProofs(meltQuote: MeltQuoteResponse, proofsToSend: Array<Proof>, options?: {
        keysetId?: string;
        counter?: number;
        privkey?: string;
    }): Promise<MeltProofsResponse>;
    // (undocumented)
    mint: CashuMint;
    // Warning: (ae-forgotten-export) The symbol "MintInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get mintInfo(): MintInfo;
    mintProofs(amount: number, quote: string, options?: {
        keysetId?: string;
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
    }): Promise<Array<Proof>>;
    onMeltQuotePaid(quoteId: string, callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMeltQuoteUpdates(quoteIds: Array<string>, callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMintQuotePaid(quoteId: string, callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    // Warning: (ae-forgotten-export) The symbol "SubscriptionCanceller" needs to be exported by the entry point index.d.ts
    onMintQuoteUpdates(quoteIds: Array<string>, callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onProofStateUpdates(proofs: Array<Proof>, callback: (payload: ProofState & {
        proof: Proof;
    }) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    receive(token: string | Token, options?: {
        keysetId?: string;
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
        requireDleq?: boolean;
    }): Promise<Array<Proof>>;
    restore(start: number, count: number, options?: {
        keysetId?: string;
    }): Promise<{
        proofs: Array<Proof>;
    }>;
    // (undocumented)
    selectProofsToSend(proofs: Array<Proof>, amountToSend: number, includeFees?: boolean): SendResponse;
    send(amount: number, proofs: Array<Proof>, options?: {
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
        keysetId?: string;
        offline?: boolean;
        includeFees?: boolean;
        includeDleq?: boolean;
    }): Promise<SendResponse>;
    swap(amount: number, proofs: Array<Proof>, options?: {
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
        keysetId?: string;
        includeFees?: boolean;
    }): Promise<SendResponse>;
    // (undocumented)
    get unit(): string;
}

// @public
export enum CheckStateEnum {
    // (undocumented)
    PENDING = "PENDING",
    // (undocumented)
    SPENT = "SPENT",
    // (undocumented)
    UNSPENT = "UNSPENT"
}

// @public
export type CheckStatePayload = {
    Ys: Array<string>;
};

// @public
export type CheckStateResponse = {
    states: Array<ProofState>;
} & ApiError;

// @public (undocumented)
export function decodePaymentRequest(paymentRequest: string): PaymentRequest_2;

// @public
export type DeprecatedToken = {
    token: Array<TokenEntry>;
    memo?: string;
    unit?: string;
};

// @public
export function deriveKeysetId(keys: Keys): string;

// @public
export function getDecodedToken(token: string): Token;

// @public
export function getEncodedToken(token: Token, opts?: {
    version: 3 | 4;
}): string;

// @public (undocumented)
export function getEncodedTokenV4(token: Token): string;

// @public
export type GetInfoResponse = {
    name: string;
    pubkey: string;
    version: string;
    description?: string;
    description_long?: string;
    contact: Array<MintContactInfo>;
    nuts: {
        '4': {
            methods: Array<SwapMethod>;
            disabled: boolean;
        };
        '5': {
            methods: Array<SwapMethod>;
            disabled: boolean;
        };
        '7'?: {
            supported: boolean;
        };
        '8'?: {
            supported: boolean;
        };
        '9'?: {
            supported: boolean;
        };
        '10'?: {
            supported: boolean;
        };
        '11'?: {
            supported: boolean;
        };
        '12'?: {
            supported: boolean;
        };
        '14'?: {
            supported: boolean;
        };
        '15'?: {
            methods: Array<MPPMethod>;
        };
        '17'?: {
            supported: Array<WebSocketSupport>;
        };
    };
    motd?: string;
};

// @public (undocumented)
export function injectWebSocketImpl(ws: any): void;

// @public (undocumented)
export type InvoiceData = {
    paymentRequest: string;
    amountInSats?: number;
    amountInMSats?: number;
    timestamp?: number;
    paymentHash?: string;
    memo?: string;
    expiry?: number;
};

// @public (undocumented)
export type JsonRpcErrorObject = {
    code: number;
    message: string;
    data?: any;
};

// Warning: (ae-forgotten-export) The symbol "JsonRpcRequest" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "JsonRpcSuccess" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "JsonRpcError" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type JsonRpcMessage = JsonRpcRequest | JsonRpcNotification | JsonRpcSuccess | JsonRpcError;

// @public (undocumented)
export type JsonRpcNotification = {
    jsonrpc: '2.0';
    method: string;
    params?: JsonRpcParams;
};

// @public (undocumented)
export type JsonRpcReqParams = {
    kind: RpcSubKinds;
    filters: Array<string>;
    subId: string;
};

// @public
export type Keys = {
    [amount: number]: string;
};

// @public
export type MeltPayload = {
    quote: string;
    inputs: Array<Proof>;
    outputs: Array<SerializedBlindedMessage>;
};

// @public
export type MeltProofsResponse = {
    quote: MeltQuoteResponse;
    change: Array<Proof>;
};

// @public
export type MeltQuotePayload = {
    unit: string;
    request: string;
};

// @public
export type MeltQuoteResponse = {
    quote: string;
    amount: number;
    fee_reserve: number;
    state: MeltQuoteState;
    expiry: number;
    payment_preimage: string | null;
    change?: Array<SerializedBlindedSignature>;
} & ApiError;

// @public (undocumented)
export enum MeltQuoteState {
    // (undocumented)
    PAID = "PAID",
    // (undocumented)
    PENDING = "PENDING",
    // (undocumented)
    UNPAID = "UNPAID"
}

// @public
export type MintActiveKeys = {
    keysets: Array<MintKeys>;
};

// @public
export type MintAllKeysets = {
    keysets: Array<MintKeyset>;
};

// @public (undocumented)
export type MintContactInfo = {
    method: string;
    info: string;
};

// @public
export type MintKeys = {
    id: string;
    unit: string;
    keys: Keys;
};

// @public
export type MintKeyset = {
    id: string;
    unit: string;
    active: boolean;
    input_fee_ppk?: number;
};

// @public
export type MintPayload = {
    quote: string;
    outputs: Array<SerializedBlindedMessage>;
};

// @public
export type MintQuotePayload = {
    unit: string;
    amount: number;
    description?: string;
};

// @public
export type MintQuoteResponse = {
    request: string;
    quote: string;
    state: MintQuoteState;
    expiry: number;
} & ApiError;

// @public (undocumented)
export enum MintQuoteState {
    // (undocumented)
    ISSUED = "ISSUED",
    // (undocumented)
    PAID = "PAID",
    // (undocumented)
    UNPAID = "UNPAID"
}

// @public
export type MintResponse = {
    signatures: Array<SerializedBlindedSignature>;
} & ApiError;

// @public
export type MPPMethod = {
    method: string;
    unit: string;
};

// @public (undocumented)
export type OutputAmounts = {
    sendAmounts: Array<number>;
    keepAmounts?: Array<number>;
};

// @public
export type PaymentPayload = {
    pr: string;
    proofs: Array<Proof>;
};

// @public (undocumented)
class PaymentRequest_2 {
    constructor(transport: Array<PaymentRequestTransport>, id?: string | undefined, amount?: number | undefined, unit?: string | undefined, mints?: string[] | undefined, description?: string | undefined, singleUse?: boolean);
    // (undocumented)
    amount?: number | undefined;
    // (undocumented)
    description?: string | undefined;
    // (undocumented)
    static fromEncodedRequest(encodedRequest: string): PaymentRequest_2;
    // (undocumented)
    getTransport(type: PaymentRequestTransportType): PaymentRequestTransport | undefined;
    // (undocumented)
    id?: string | undefined;
    // (undocumented)
    mints?: string[] | undefined;
    // (undocumented)
    singleUse: boolean;
    // (undocumented)
    toEncodedRequest(): string;
    // (undocumented)
    transport: Array<PaymentRequestTransport>;
    // (undocumented)
    unit?: string | undefined;
}
export { PaymentRequest_2 as PaymentRequest }

// @public (undocumented)
export type PaymentRequestPayload = {
    id?: string;
    memo?: string;
    unit: string;
    mint: string;
    proofs: Array<Proof>;
};

// @public (undocumented)
export type PaymentRequestTransport = {
    type: PaymentRequestTransportType;
    target: string;
    tags?: Array<Array<string>>;
};

// @public (undocumented)
export enum PaymentRequestTransportType {
    // (undocumented)
    NOSTR = "nostr",
    // (undocumented)
    POST = "post"
}

// @public
export type PostRestorePayload = {
    outputs: Array<SerializedBlindedMessage>;
};

// @public
export type PostRestoreResponse = {
    outputs: Array<SerializedBlindedMessage>;
    promises: Array<SerializedBlindedSignature>;
};

// @public
export type Proof = {
    id: string;
    amount: number;
    secret: string;
    C: string;
    dleq?: SerializedDLEQ;
    dleqValid?: boolean;
};

// @public
export type ProofState = {
    Y: string;
    state: CheckStateEnum;
    witness: string | null;
};

// @public (undocumented)
export type RawPaymentRequest = {
    i?: string;
    a?: number;
    u?: string;
    s?: boolean;
    m?: Array<string>;
    d?: string;
    t: Array<RawTransport>;
};

// @public (undocumented)
export type RawTransport = {
    t: PaymentRequestTransportType;
    a: string;
    g?: Array<Array<string>>;
};

// @public
export type ReceiveResponse = {
    token: Token;
    tokensWithErrors: Token | undefined;
};

// @public
export type ReceiveTokenEntryResponse = {
    proofs: Array<Proof>;
};

// @public (undocumented)
export type RpcSubId = string | number | null;

// @public
export type SendResponse = {
    keep: Array<Proof>;
    send: Array<Proof>;
};

// @public
export type SerializedBlindedMessage = {
    amount: number;
    B_: string;
    id: string;
};

// @public
export type SerializedBlindedSignature = {
    id: string;
    amount: number;
    C_: string;
    dleq?: SerializedDLEQ;
};

// @public (undocumented)
export type SerializedDLEQ = {
    s: string;
    e: string;
    r?: string;
};

// Warning: (ae-forgotten-export) The symbol "RequestOptions" needs to be exported by the entry point index.d.ts
//
// @public
export function setGlobalRequestOptions(options: Partial<RequestOptions>): void;

// @public
export type SwapMethod = {
    method: string;
    unit: string;
    min_amount: number;
    max_amount: number;
};

// @public
export type SwapPayload = {
    inputs: Array<Proof>;
    outputs: Array<SerializedBlindedMessage>;
};

// @public
export type SwapResponse = {
    signatures: Array<SerializedBlindedSignature>;
} & ApiError;

// @public
export type Token = {
    mint: string;
    proofs: Array<Proof>;
    memo?: string;
    unit?: string;
};

// @public @deprecated (undocumented)
export type TokenV2 = {
    proofs: Array<Proof>;
    mints: Array<{
        url: string;
        ids: Array<string>;
    }>;
};

// @public
export type TokenV4Template = {
    t: Array<V4InnerToken>;
    d: string;
    m: string;
    u: string;
};

// @public (undocumented)
export type V4DLEQTemplate = {
    e: Uint8Array;
    s: Uint8Array;
    r: Uint8Array;
};

// @public
export type V4InnerToken = {
    i: Uint8Array;
    p: Array<V4ProofTemplate>;
};

// @public
export type V4ProofTemplate = {
    a: number;
    s: string;
    c: Uint8Array;
    d?: V4DLEQTemplate;
};

// @public
export type WebSocketSupport = {
    method: string;
    unit: string;
    commands: Array<string>;
};

// Warnings were encountered during analysis:
//
// dist/lib/es6/model/types/index.d.ts:20:5 - (ae-forgotten-export) The symbol "RpcSubKinds" needs to be exported by the entry point index.d.ts
// dist/lib/es6/model/types/index.d.ts:48:5 - (ae-forgotten-export) The symbol "JsonRpcParams" needs to be exported by the entry point index.d.ts
// dist/lib/es6/model/types/wallet/tokens.d.ts:99:5 - (ae-forgotten-export) The symbol "TokenEntry" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
