## API Report File for "@cashu/cashu-ts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';

// @public
export function assertSecretKind(allowed: SecretKind | SecretKind[], secret: Secret | string): Secret;

// @public
export class AuthManager implements AuthProvider {
    constructor(mintUrl: string, opts?: AuthManagerOptions);
    // (undocumented)
    get activeAuthKeysetId(): string | undefined;
    attachOIDC(oidc: OIDCAuth): this;
    ensure(minTokens: number): Promise<void>;
    ensureCAT(minValidSecs?: number): Promise<string | undefined>;
    exportPool(): Proof[];
    getBlindAuthToken({ method, path, }: {
        method: 'GET' | 'POST';
        path: string;
    }): Promise<string>;
    // (undocumented)
    getCAT(): string | undefined;
    // (undocumented)
    get hasCAT(): boolean;
    importPool(proofs: Proof[], mode?: 'replace' | 'merge'): void;
    // (undocumented)
    get poolSize(): number;
    // (undocumented)
    get poolTarget(): number;
    // (undocumented)
    setCAT(cat: string | undefined): void;
}

// @public (undocumented)
export type AuthManagerOptions = {
    maxPerMint?: number;
    desiredPoolSize?: number;
    request?: RequestFn;
    logger?: Logger;
};

// @public (undocumented)
export interface AuthProvider {
    // (undocumented)
    ensure?(minTokens: number): Promise<void>;
    ensureCAT?(minValiditySec?: number): Promise<string | undefined>;
    // (undocumented)
    getBlindAuthToken(input: {
        method: 'GET' | 'POST';
        path: string;
    }): Promise<string>;
    // (undocumented)
    getCAT(): string | undefined;
    // (undocumented)
    setCAT(cat: string | undefined): void;
}

// @public (undocumented)
export function bigIntStringify<T>(_key: unknown, value: T): string | T;

// @public @deprecated (undocumented)
export type BlindedMessage = RawBlindedMessage;

// @public
export function blindMessage(secret: Uint8Array, r?: bigint): RawBlindedMessage;

// @public (undocumented)
export type BlindSignature = {
    C_: WeierstrassPoint<bigint>;
    amount: number;
    id: string;
};

// @public @deprecated
export type Bolt12MeltQuotePayload = MeltQuoteBolt12Request;

// @public @deprecated (undocumented)
export type Bolt12MeltQuoteResponse = MeltQuoteBolt12Response;

// @public @deprecated
export type Bolt12MintQuotePayload = MintQuoteBolt12Request;

// @public @deprecated
export type Bolt12MintQuoteResponse = MintQuoteBolt12Response;

// @public @deprecated
export function bytesToNumber(bytes: Uint8Array): bigint;

// @public (undocumented)
export type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;

// @public (undocumented)
export function checkResponse(data: {
    error?: string;
    detail?: string;
}): void;

// @public
export const CheckStateEnum: {
    readonly UNSPENT: "UNSPENT";
    readonly PENDING: "PENDING";
    readonly SPENT: "SPENT";
};

// @public (undocumented)
export type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];

// @public
export type CheckStatePayload = {
    Ys: string[];
};

// @public
export type CheckStateResponse = {
    states: ProofState[];
};

// @public
export class ConsoleLogger implements Logger {
    constructor(minLevel?: LogLevel);
    // (undocumented)
    debug(msg: string, ctx?: Record<string, unknown>): void;
    // (undocumented)
    error(msg: string, ctx?: Record<string, unknown>): void;
    // (undocumented)
    info(msg: string, ctx?: Record<string, unknown>): void;
    // (undocumented)
    log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    trace(msg: string, ctx?: Record<string, unknown>): void;
    // (undocumented)
    warn(msg: string, ctx?: Record<string, unknown>): void;
}

// @public (undocumented)
export function constructProofFromPromise(promise: BlindSignature, r: bigint, secret: Uint8Array, key: WeierstrassPoint<bigint>): RawProof;

// @public
export interface CounterRange {
    // (undocumented)
    count: number;
    // (undocumented)
    start: number;
}

// @public (undocumented)
export interface CounterSource {
    advanceToAtLeast(keysetId: string, minNext: number): Promise<void>;
    reserve(keysetId: string, n: number): Promise<CounterRange>;
    setNext?(keysetId: string, next: number): Promise<void>;
    snapshot?(): Promise<Record<string, number>>;
}

// @public
export function createAuthWallet(mintUrl: string, options?: {
    authPool?: number;
    oidc?: OIDCAuthOptions;
    logger?: Logger;
}): Promise<{
    mint: Mint;
    auth: AuthManager;
    oidc: OIDCAuth;
    wallet: Wallet;
}>;

// @public (undocumented)
export function createBlindSignature(B_: WeierstrassPoint<bigint>, privateKey: Uint8Array, amount: number, id: string): BlindSignature;

// @public
export const createDLEQProof: (B_: WeierstrassPoint<bigint>, a: Uint8Array) => DLEQ;

// @public
export function createHTLCHash(preimage?: string): {
    hash: string;
    preimage: string;
};

// @public
export function createHTLCsecret(hash: string, tags?: string[][]): string;

// @public
export function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array, options?: {
    expiry?: number;
    input_fee_ppk?: number;
    unit?: string;
    versionByte?: number;
}): KeysetPair;

// @public
export function createP2PKsecret(pubkey: string, tags?: string[][]): string;

// @public @deprecated (undocumented)
export function createRandomBlindedMessage(_deprecated?: PrivKey): RawBlindedMessage;

// @public
export function createRandomRawBlindedMessage(): RawBlindedMessage;

// @public (undocumented)
export function createRandomSecretKey(): Uint8Array<ArrayBufferLike>;

// @public
export function createSecret(kind: SecretKind, data: string, tags?: string[][]): string;

// @public (undocumented)
export function decodePaymentRequest(paymentRequest: string): PaymentRequest_2;

// @public
export function deepEqual<T>(a: T, b: T): boolean;

// @public (undocumented)
export const deriveBlindingFactor: (seed: Uint8Array, keysetId: string, counter: number) => Uint8Array;

// @public
export function deriveKeysetId(keys: Keys, options?: DeriveKeysetIdOptions): string;

// @public @deprecated (undocumented)
export function deriveKeysetId(keys: Keys, unit?: string, expiry?: number, versionByte?: number, isDeprecatedBase64?: boolean): string;

// @public (undocumented)
export type DeriveKeysetIdOptions = {
    expiry?: number;
    input_fee_ppk?: number;
    unit?: string;
    versionByte?: number;
    isDeprecatedBase64?: boolean;
};

// @public
export function deriveP2BKBlindedPubkeys(pubkeys: string[], keysetId: string, eBytes?: Uint8Array): {
    blinded: string[];
    Ehex: string;
};

// @public
export function deriveP2BKSecretKey(privkey: string | bigint, rBlind: string | bigint, blindPubkey?: Uint8Array, naturalPub?: Uint8Array): string | null;

// @public
export function deriveP2BKSecretKeys(Ehex: string, privateKey: string | string[], blindPubKey: string | string[], keysetIdHex: string): string[];

// @public (undocumented)
export const deriveSecret: (seed: Uint8Array, keysetId: string, counter: number) => Uint8Array;

// @public (undocumented)
export function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys;

// @public (undocumented)
export const deserializeProof: (proof: SerializedProof) => RawProof;

// @public (undocumented)
export type DeviceStartResponse = {
    device_code: string;
    user_code: string;
    verification_uri: string;
    verification_uri_complete?: string;
    interval?: number;
    expires_in?: number;
};

// @public (undocumented)
export type DLEQ = {
    s: Uint8Array;
    e: Uint8Array;
    r?: bigint;
};

// @public (undocumented)
export type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N ? Acc[number] : Enumerate<N, [...Acc, Acc['length']]>;

// @public
export function getDataField(secret: Secret | string): string;

// @public
export function getDecodedToken(tokenString: string, keysetIds?: readonly string[]): Token;

// @public @deprecated (undocumented)
export function getDecodedToken(tokenString: string, keysetIds?: readonly HasKeysetId[]): Token;

// @public (undocumented)
export function getDecodedTokenBinary(bytes: Uint8Array): Token;

// @public
export function getEncodedToken(token: Token, opts?: {
    version?: 3 | 4;
    removeDleq?: boolean;
}): string;

// @public (undocumented)
export function getEncodedTokenBinary(token: Token): Uint8Array;

// @public
export function getEncodedTokenV3(token: Token, removeDleq?: boolean): string;

// @public (undocumented)
export function getEncodedTokenV4(token: Token, removeDleq?: boolean): string;

// @public
export function getHTLCWitnessPreimage(witness: Proof['witness']): string | undefined;

// @public
export type GetInfoResponse = {
    name: string;
    pubkey: string;
    version: string;
    description?: string;
    description_long?: string;
    icon_url?: string;
    contact: MintContactInfo[];
    nuts: {
        '4': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '5': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '7'?: {
            supported: boolean;
        };
        '8'?: {
            supported: boolean;
        };
        '9'?: {
            supported: boolean;
        };
        '10'?: {
            supported: boolean;
        };
        '11'?: {
            supported: boolean;
        };
        '12'?: {
            supported: boolean;
        };
        '14'?: {
            supported: boolean;
        };
        '15'?: {
            methods: MPPMethod[];
        };
        '17'?: {
            supported: WebSocketSupport[];
        };
        '20'?: {
            supported: boolean;
        };
        '21'?: {
            openid_discovery: string;
            client_id: string;
            protected_endpoints?: Array<{
                method: 'GET' | 'POST';
                path: string;
            }>;
        };
        '22'?: {
            bat_max_mint: number;
            protected_endpoints: Array<{
                method: 'GET' | 'POST';
                path: string;
            }>;
        };
    };
    motd?: string;
};

// @public
export function getKeepAmounts(proofsWeHave: Proof[], amountToKeep: number, keys: Keys, targetCount: number): number[];

// @public
export function getKeysetAmounts(keyset: Keys, order?: 'asc' | 'desc'): number[];

// @public (undocumented)
export const getKeysetIdInt: (keysetId: string) => bigint;

// @public
export type GetKeysetsResponse = {
    keysets: MintKeyset[];
};

// @public
export type GetKeysResponse = {
    keysets: MintKeys[];
};

// @public @deprecated (undocumented)
export function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[];

// @public
export function getP2PKExpectedWitnessPubkeys(secretStr: string | Secret): string[];

// @public
export function getP2PKLockState(secretStr: Secret | string, nowSeconds?: number): LockState;

// @public
export function getP2PKLocktime(secretStr: string | Secret): number;

// @public
export function getP2PKNSigs(secretStr: string | Secret): number;

// @public
export function getP2PKNSigsRefund(secretStr: string | Secret): number;

// @public
export function getP2PKSigFlag(secretStr: string | Secret): SigFlag;

// @public
export function getP2PKWitnessPubkeys(secretStr: string | Secret): string[];

// @public
export function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[];

// @public
export function getP2PKWitnessSignatures(witness: Proof['witness']): string[];

// @public (undocumented)
export function getPubKeyFromPrivKey(privKey: Uint8Array): Uint8Array<ArrayBufferLike>;

// @public
export function getSecretData(secret: Secret | string): SecretData;

// @public
export function getSecretKind(secret: Secret | string): SecretKind;

// @public
export function getTag(secret: Secret | string, key: string): string[] | undefined;

// @public
export function getTagInt(secret: Secret | string, key: string): number | undefined;

// @public
export function getTags(secret: Secret | string): string[][];

// @public
export function getTagScalar(secret: Secret | string, key: string): string | undefined;

// @public
export function getTokenMetadata(token: string): TokenMetadata;

// @public
export function getValidSigners(signatures: string[], message: string, pubkeys: string[]): string[];

// @public
export function handleTokens(token: string): Token;

// @public
export function hasCorrespondingKey(amount: number, keyset: Keys): boolean;

// @public (undocumented)
export function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array;

// @public (undocumented)
export function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint>;

// @public
export type HasKeysetId = {
    id: string;
};

// @public
export type HasKeysetKeys = {
    id: string;
    keys: Keys;
};

// @public
export function hasNonHexId(p: Proof | Proof[]): boolean;

// @public
export function hasP2PKSignedProof(pubkey: string, proof: Proof, message?: string): boolean;

// @public
export function hasTag(secret: Secret | string, key: string): boolean;

// @public
export function hasValidDleq(proof: Proof, keyset: HasKeysetKeys): boolean;

// @public
export function hexToNumber(hex: string): bigint;

// @public
export type HTLCWitness = {
    preimage: string;
    signatures?: string[];
};

// @public
export class HttpResponseError extends Error {
    constructor(message: string, status: number);
    // (undocumented)
    status: number;
}

// @public (undocumented)
export function injectWebSocketImpl(ws: typeof WebSocket): void;

// @public (undocumented)
export type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;

// @public
export function invoiceHasAmountInHRP(invoice: string): boolean;

// @public
export function isHTLCSpendAuthorised(proof: Proof, logger?: Logger, message?: string): boolean;

// @public (undocumented)
export function isObj(v: unknown): v is object;

// @public
export function isP2PKSpendAuthorised(proof: Proof, logger?: Logger, message?: string): boolean;

// @public (undocumented)
export function isValidHex(str: string): boolean;

// @public (undocumented)
export function joinUrls(...parts: string[]): string;

// @public (undocumented)
export type JsonRpcReqParams = {
    kind: RpcSubKinds;
    filters: string[];
    subId: string;
};

// @public
export class KeyChain {
    constructor(mint: string | Mint, unit: string, cachedKeysets?: MintKeyset[], cachedKeys?: MintKeys[] | MintKeys);
    get cache(): KeyChainCache;
    static cacheToMintDTO(cache: KeyChainCache): {
        keysets: MintKeyset[];
        keys: MintKeys[];
    };
    static fromCache(mint: string | Mint, cache: KeyChainCache): KeyChain;
    getAllKeys(): MintKeys[];
    getAllKeysetIds(): string[];
    // @deprecated
    getCache(): {
        keysets: MintKeyset[];
        keys: MintKeys[];
        unit: string;
        mintUrl: string;
    };
    getCheapestKeyset(): Keyset;
    getKeyset(id?: string): Keyset;
    getKeysets(): Keyset[];
    init(forceRefresh?: boolean): Promise<void>;
    loadFromCache(cache: KeyChainCache): void;
    static mintToCacheDTO(unit: string, mintUrl: string, allKeysets: MintKeyset[], allKeys: MintKeys[]): KeyChainCache;
}

// @public
export type KeyChainCache = {
    keysets: KeysetCache[];
    unit: string;
    mintUrl: string;
};

// @public
export type Keys = {
    [amount: number]: string;
};

// @public (undocumented)
export class Keyset {
    constructor(id: string, unit: string, active: boolean, input_fee_ppk?: number, final_expiry?: number);
    // @deprecated (undocumented)
    get active(): boolean;
    // (undocumented)
    get expiry(): number | undefined;
    // (undocumented)
    get fee(): number;
    // @deprecated (undocumented)
    get final_expiry(): number | undefined;
    static fromMintApi(meta: MintKeyset, keys?: MintKeys): Keyset;
    // (undocumented)
    get hasHexId(): boolean;
    // (undocumented)
    get hasKeys(): boolean;
    // (undocumented)
    get id(): string;
    // @deprecated (undocumented)
    get input_fee_ppk(): number;
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    get keys(): Record<number, string>;
    set keys(keys: Record<number, string>);
    toMintKeys(): MintKeys | null;
    toMintKeyset(): MintKeyset;
    // (undocumented)
    get unit(): string;
    verify(): boolean;
    static verifyKeysetId(keys: MintKeys): boolean;
}

// @public
export type KeysetCache = MintKeyset & {
    keys?: Keys;
};

// @public (undocumented)
export type KeysetPair = {
    keysetId: string;
    pubKeys: RawMintKeys;
    privKeys: RawMintKeys;
};

// @public @deprecated (undocumented)
export type LockedMintQuoteResponse = MintQuoteBolt11Response;

// @public (undocumented)
export type LockState = 'PERMANENT' | 'ACTIVE' | 'EXPIRED';

// @public (undocumented)
export interface Logger {
    // (undocumented)
    debug(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    error(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    info(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    trace(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    warn(message: string, context?: Record<string, unknown>): void;
}

// @public
export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';

// @public
export function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[];

// @public
export const meetsSignerThreshold: (signatures: string[], message: string, pubkeys: string[], threshold?: number) => boolean;

// @public @deprecated (undocumented)
export interface MeltBlanks<T extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
    // (undocumented)
    keyset: Keyset;
    // (undocumented)
    method: 'bolt11' | 'bolt12';
    // (undocumented)
    outputData: OutputDataLike[];
    // (undocumented)
    payload: MeltRequest;
    // (undocumented)
    quote: T;
}

// @public
export class MeltBuilder<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
    constructor(wallet: Wallet, method: string, quote: TQuote, proofs: Proof[]);
    asCustom(data: OutputDataLike[]): this;
    asDeterministic(counter?: number, denoms?: number[]): this;
    asFactory(factory: OutputDataFactory, denoms?: number[]): this;
    asP2PK(options: P2PKOptions, denoms?: number[]): this;
    asRandom(denoms?: number[]): this;
    keyset(id: string): this;
    // @deprecated
    onChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>): this;
    onCountersReserved(cb: OnCountersReserved): this;
    prepare(): Promise<MeltPreview<TQuote>>;
    privkey(k: string | string[]): this;
    run(): Promise<MeltProofsResponse<TQuote>>;
}

// @public
export interface MeltPreview<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
    inputs: Proof[];
    keysetId: string;
    // (undocumented)
    method: string;
    outputData: OutputDataLike[];
    quote: TQuote;
}

// @public
export type MeltProofsConfig = {
    keysetId?: string;
    privkey?: string | string[];
    onChangeOutputsCreated?: (blanks: MeltBlanks<MeltQuoteBaseResponse>) => void;
    onCountersReserved?: OnCountersReserved;
};

// @public
export type MeltProofsResponse<TQuote extends MeltQuoteBaseResponse = MeltQuoteBaseResponse> = {
    quote: TQuote;
    change: Proof[];
};

// @public
export type MeltQuoteBaseRequest = {
    unit: string;
    request: string;
};

// @public
export type MeltQuoteBaseResponse = {
    quote: string;
    amount: number;
    unit: string;
    state: MeltQuoteState;
    expiry: number;
    change?: SerializedBlindedSignature[];
};

// @public
export type MeltQuoteBolt11Request = MeltQuoteBaseRequest & {
    options?: {
        amountless?: {
            amount_msat: number;
        };
        mpp?: {
            amount: number;
        };
    };
};

// @public
export type MeltQuoteBolt11Response = MeltQuoteBaseResponse & {
    request: string;
    fee_reserve: number;
    payment_preimage: string | null;
};

// @public
export type MeltQuoteBolt12Request = MeltQuoteBaseRequest & {
    options?: {
        amountless?: {
            amount_msat: number;
        };
    };
};

// @public
export type MeltQuoteBolt12Response = MeltQuoteBolt11Response;

// @public @deprecated (undocumented)
export type MeltQuoteResponse = MeltQuoteBolt11Response;

// @public (undocumented)
export const MeltQuoteState: {
    readonly UNPAID: "UNPAID";
    readonly PENDING: "PENDING";
    readonly PAID: "PAID";
};

// @public (undocumented)
export type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];

// @public
export type MeltRequest = {
    quote: string;
    inputs: Proof[];
    outputs?: SerializedBlindedMessage[];
} & Record<string, unknown>;

// @public (undocumented)
export function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array;

// @public (undocumented)
export class MessageNode {
    constructor(message: string);
    // (undocumented)
    get next(): MessageNode | null;
    set next(node: MessageNode | null);
    // (undocumented)
    get value(): string;
    set value(message: string);
}

// @public (undocumented)
export class MessageQueue {
    constructor();
    // (undocumented)
    dequeue(): string | null;
    // (undocumented)
    enqueue(message: string): boolean;
    // (undocumented)
    get first(): MessageNode | null;
    set first(messageNode: MessageNode | null);
    // (undocumented)
    get last(): MessageNode | null;
    set last(messageNode: MessageNode | null);
    // (undocumented)
    get size(): number;
    set size(v: number);
}

// @public
export class Mint {
    constructor(mintUrl: string, options?: {
        customRequest?: RequestFn;
        authProvider?: AuthProvider;
        logger?: Logger;
    });
    check(checkPayload: CheckStatePayload, customRequest?: RequestFn): Promise<CheckStateResponse>;
    checkMeltQuoteBolt11(quote: string, customRequest?: RequestFn): Promise<MeltQuoteBolt11Response>;
    checkMeltQuoteBolt12(quote: string, customRequest?: RequestFn): Promise<MeltQuoteBolt12Response>;
    checkMintQuoteBolt11(quote: string, customRequest?: RequestFn): Promise<MintQuoteBolt11Response>;
    checkMintQuoteBolt12(quote: string, customRequest?: RequestFn): Promise<MintQuoteBolt12Response>;
    connectWebSocket(): Promise<void>;
    createMeltQuoteBolt11(meltQuotePayload: MeltQuoteBolt11Request, customRequest?: RequestFn): Promise<MeltQuoteBolt11Response>;
    createMeltQuoteBolt12(meltQuotePayload: MeltQuoteBolt12Request, customRequest?: RequestFn): Promise<MeltQuoteBolt12Response>;
    createMintQuoteBolt11(mintQuotePayload: MintQuoteBolt11Request, customRequest?: RequestFn): Promise<MintQuoteBolt11Response>;
    createMintQuoteBolt12(mintQuotePayload: MintQuoteBolt12Request, customRequest?: RequestFn): Promise<MintQuoteBolt12Response>;
    disconnectWebSocket(): void;
    getInfo(customRequest?: RequestFn): Promise<GetInfoResponse>;
    getKeys(keysetId?: string, mintUrl?: string, customRequest?: RequestFn): Promise<GetKeysResponse>;
    getKeySets(customRequest?: RequestFn): Promise<GetKeysetsResponse>;
    getLazyMintInfo(): Promise<MintInfo>;
    melt<TRes extends Record<string, unknown> = Record<string, unknown>>(method: string, meltPayload: MeltRequest, options?: {
        customRequest?: RequestFn;
        preferAsync?: boolean;
    }): Promise<MeltQuoteBaseResponse & TRes>;
    meltBolt11(meltPayload: MeltRequest, options?: {
        customRequest?: RequestFn;
        preferAsync?: boolean;
    }): Promise<MeltQuoteBolt11Response>;
    meltBolt12(meltPayload: MeltRequest, options?: {
        customRequest?: RequestFn;
        preferAsync?: boolean;
    }): Promise<MeltQuoteBolt12Response>;
    mintBolt11(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse>;
    mintBolt12(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse>;
    // (undocumented)
    get mintUrl(): string;
    oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth>;
    restore(restorePayload: PostRestorePayload, customRequest?: RequestFn): Promise<PostRestoreResponse>;
    swap(swapPayload: SwapRequest, customRequest?: RequestFn): Promise<SwapResponse>;
    // (undocumented)
    get webSocketConnection(): WSConnection | undefined;
}

// @public @deprecated (undocumented)
export type MintActiveKeys = GetKeysResponse;

// @public @deprecated (undocumented)
export type MintAllKeysets = GetKeysetsResponse;

// @public
export class MintBuilder<M extends MintMethod, HasPrivKey extends boolean = M extends 'bolt12' ? false : true> {
    constructor(wallet: Wallet, method: M, amount: number, quote: MintQuoteFor<M>);
    asCustom(data: OutputDataLike[]): this;
    asDeterministic(counter?: number, denoms?: number[]): this;
    asFactory(factory: OutputDataFactory, denoms?: number[]): this;
    asP2PK(options: P2PKOptions, denoms?: number[]): this;
    asRandom(denoms?: number[]): this;
    keyset(id: string): this;
    onCountersReserved(cb: OnCountersReserved): this;
    privkey(k: string): MintBuilder<M, true>;
    proofsWeHave(p: Proof[]): this;
    run(this: MintBuilder<M, true>): Promise<Proof[]>;
}

// @public (undocumented)
export type MintContactInfo = {
    method: string;
    info: string;
};

// @public (undocumented)
export class MintInfo {
    constructor(info: GetInfoResponse);
    // (undocumented)
    get cache(): GetInfoResponse;
    // (undocumented)
    get contact(): MintContactInfo[];
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    get description_long(): string | undefined;
    // (undocumented)
    isSupported(num: 4 | 5): {
        disabled: boolean;
        params: SwapMethod[];
    };
    // (undocumented)
    isSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): {
        supported: boolean;
    };
    // (undocumented)
    isSupported(num: 17): {
        supported: boolean;
        params?: WebSocketSupport[];
    };
    // (undocumented)
    isSupported(num: 15): {
        supported: boolean;
        params?: MPPMethod[];
    };
    // (undocumented)
    get motd(): string | undefined;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get nuts(): {
        '4': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '5': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '7'?: {
            supported: boolean;
        };
        '8'?: {
            supported: boolean;
        };
        '9'?: {
            supported: boolean;
        };
        '10'?: {
            supported: boolean;
        };
        '11'?: {
            supported: boolean;
        };
        '12'?: {
            supported: boolean;
        };
        '14'?: {
            supported: boolean;
        };
        '15'?: {
            methods: MPPMethod[];
        };
        '17'?: {
            supported: WebSocketSupport[];
        };
        '20'?: {
            supported: boolean;
        };
        '21'?: {
            openid_discovery: string;
            client_id: string;
            protected_endpoints?: Array<{
                method: "GET" | "POST";
                path: string;
            }>;
        };
        '22'?: {
            bat_max_mint: number;
            protected_endpoints: Array<{
                method: "GET" | "POST";
                path: string;
            }>;
        };
    };
    // (undocumented)
    get pubkey(): string;
    // (undocumented)
    requiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean;
    // (undocumented)
    requiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean;
    // (undocumented)
    supportsAmountless(method?: string, unit?: string): boolean;
    // @deprecated (undocumented)
    get supportsBolt12Description(): boolean;
    supportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean;
    // (undocumented)
    get version(): string;
}

// @public
export type MintKeys = {
    id: string;
    unit: string;
    active?: boolean;
    input_fee_ppk?: number;
    final_expiry?: number;
    keys: Keys;
};

// @public
export type MintKeyset = {
    id: string;
    unit: string;
    active: boolean;
    input_fee_ppk?: number;
    final_expiry?: number;
};

// @public (undocumented)
export type MintMethod = 'bolt11' | 'bolt12';

// @public
export class MintOperationError extends HttpResponseError {
    constructor(code: number, detail: string);
    // (undocumented)
    code: number;
}

// @public
export type MintProofsConfig = {
    keysetId?: string;
    privkey?: string;
    proofsWeHave?: Proof[];
    onCountersReserved?: OnCountersReserved;
};

// @public
export type MintQuoteBaseRequest = {
    unit: string;
    pubkey?: string;
};

// @public
export type MintQuoteBaseResponse = {
    quote: string;
    request: string;
    unit: string;
    pubkey?: string;
};

// @public
export type MintQuoteBolt11Request = MintQuoteBaseRequest & {
    amount: number;
    description?: string;
};

// @public
export type MintQuoteBolt11Response = MintQuoteBaseResponse & {
    amount: number;
    state: MintQuoteState;
    expiry: number;
};

// @public
export type MintQuoteBolt12Request = MintQuoteBaseRequest & {
    amount?: number;
    description?: string;
};

// @public
export type MintQuoteBolt12Response = MintQuoteBaseResponse & {
    amount?: number;
    expiry: number;
    pubkey: string;
    amount_paid: number;
    amount_issued: number;
};

// @public (undocumented)
export type MintQuoteFor<M extends MintMethod> = M extends 'bolt11' ? string | MintQuoteBolt11Response : MintQuoteBolt12Response;

// @public @deprecated
export type MintQuotePayload = MintQuoteBolt11Request;

// @public @deprecated (undocumented)
export type MintQuoteResponse = MintQuoteBolt11Response;

// @public (undocumented)
export const MintQuoteState: {
    readonly UNPAID: "UNPAID";
    readonly PAID: "PAID";
    readonly ISSUED: "ISSUED";
};

// @public (undocumented)
export type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];

// @public
export type MintRequest = {
    quote: string;
    outputs: SerializedBlindedMessage[];
    signature?: string;
};

// @public
export type MintResponse = {
    signatures: SerializedBlindedSignature[];
};

// @public
export type MPPMethod = {
    method: string;
    unit: string;
};

// @public
export class NetworkError extends Error {
    constructor(message: string);
}

// @public
export function numberToHexPadded64(number: bigint): string;

// @public
export type NUT10Option = {
    kind: string;
    data: string;
    tags: string[][];
};

// @public (undocumented)
export class OIDCAuth {
    constructor(discoveryUrl: string, opts?: OIDCAuthOptions);
    addTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void;
    buildAuthCodeUrl(input: {
        redirectUri: string;
        codeChallenge: string;
        codeChallengeMethod?: 'S256' | 'plain';
        state?: string;
        scope?: string;
    }): Promise<string>;
    // (undocumented)
    devicePoll(device_code: string, intervalSec?: number): Promise<TokenResponse>;
    // (undocumented)
    deviceStart(): Promise<DeviceStartResponse>;
    exchangeAuthCode(input: {
        code: string;
        redirectUri: string;
        codeVerifier: string;
    }): Promise<TokenResponse>;
    // (undocumented)
    static fromMintInfo(info: {
        nuts: GetInfoResponse['nuts'];
    }, opts?: OIDCAuthOptions): OIDCAuth;
    generatePKCE(): {
        verifier: string;
        challenge: string;
    };
    // (undocumented)
    loadConfig(): Promise<OIDCConfig>;
    // (undocumented)
    passwordGrant(username: string, password: string): Promise<TokenResponse>;
    // (undocumented)
    refresh(refresh_token: string): Promise<TokenResponse>;
    // (undocumented)
    setClient(id: string): void;
    // (undocumented)
    setScope(scope?: string): void;
    startDeviceAuth(intervalSec?: number): Promise<DeviceStartResponse & {
        poll: () => Promise<TokenResponse>;
        cancel: () => void;
    }>;
}

// @public (undocumented)
export type OIDCAuthOptions = {
    clientId?: string;
    scope?: string;
    logger?: Logger;
    onTokens?: (t: TokenResponse) => void | Promise<void>;
};

// @public (undocumented)
export type OIDCConfig = {
    issuer: string;
    authorization_endpoint?: string;
    token_endpoint: string;
    device_authorization_endpoint?: string;
};

// @public (undocumented)
export type OnCountersReserved = (info: OperationCounters) => void;

// @public
export type OperationCounters = {
    keysetId: string;
    start: number;
    count: number;
    next: number;
};

// @public
export interface OutputConfig {
    // (undocumented)
    keep?: OutputType;
    // (undocumented)
    send: OutputType;
}

// @public (undocumented)
export class OutputData implements OutputDataLike<HasKeysetKeys> {
    constructor(blindedMessage: SerializedBlindedMessage, blindingFactor: bigint, secret: Uint8Array);
    // (undocumented)
    blindedMessage: SerializedBlindedMessage;
    // (undocumented)
    blindingFactor: bigint;
    // (undocumented)
    static createDeterministicData<T extends HasKeysetKeys>(amount: number, seed: Uint8Array, counter: number, keyset: T, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createP2PKData<T extends HasKeysetKeys>(p2pk: P2PKOptions, amount: number, keyset: T, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createRandomData<T extends HasKeysetKeys>(amount: number, keyset: T, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createSingleDeterministicData(amount: number, seed: Uint8Array, counter: number, keysetId: string): OutputData;
    // (undocumented)
    static createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string): OutputData;
    // (undocumented)
    static createSingleRandomData(amount: number, keysetId: string): OutputData;
    // (undocumented)
    secret: Uint8Array;
    static sumOutputAmounts(outputs: OutputDataLike[]): number;
    // (undocumented)
    toProof(sig: SerializedBlindedSignature, keyset: HasKeysetKeys): Proof;
}

// @public
export type OutputDataFactory<TKeyset extends HasKeysetKeys = HasKeysetKeys> = (amount: number, keys: TKeyset) => OutputDataLike<TKeyset>;

// @public
export interface OutputDataLike<TKeyset extends HasKeysetKeys = HasKeysetKeys> {
    // (undocumented)
    blindedMessage: SerializedBlindedMessage;
    // (undocumented)
    blindingFactor: bigint;
    // (undocumented)
    secret: Uint8Array;
    // (undocumented)
    toProof: (signature: SerializedBlindedSignature, keyset: TKeyset) => Proof;
}

// @public
export type OutputType = ({
    type: 'random';
} & SharedOutputTypeProps) | ({
    type: 'deterministic';
    counter: number;
} & SharedOutputTypeProps) | ({
    type: 'p2pk';
    options: P2PKOptions;
} & SharedOutputTypeProps) | ({
    type: 'factory';
    factory: OutputDataFactory;
} & SharedOutputTypeProps) | {
    type: 'custom';
    data: OutputDataLike[];
};

// @public
export const P2BK_DST: Uint8Array<ArrayBufferLike>;

// @public (undocumented)
export class P2PKBuilder {
    addHashlock(hashlock: string): this;
    // (undocumented)
    addLockPubkey(pk: string | string[]): this;
    // (undocumented)
    addRefundPubkey(pk: string | string[]): this;
    // (undocumented)
    addTag(key: string, values?: string[] | string): this;
    // (undocumented)
    addTags(tags: P2PKTag[]): this;
    // (undocumented)
    blindKeys(): this;
    // (undocumented)
    static fromOptions(opts: P2PKOptions): P2PKBuilder;
    // (undocumented)
    lockUntil(when: Date | number): this;
    // (undocumented)
    requireLockSignatures(n: number): this;
    // (undocumented)
    requireRefundSignatures(n: number): this;
    // (undocumented)
    sigAll(): this;
    // (undocumented)
    toOptions(): P2PKOptions;
}

// @public
export type P2PKOptions = {
    pubkey: string | string[];
    locktime?: number;
    refundKeys?: string[];
    requiredSignatures?: number;
    requiredRefundSignatures?: number;
    additionalTags?: P2PKTag[];
    blindKeys?: boolean;
    sigFlag?: SigFlag;
    hashlock?: string;
};

// @public (undocumented)
export type P2PKSpendingPath = 'MAIN' | 'REFUND' | 'UNLOCKED' | 'FAILED';

// @public (undocumented)
export type P2PKTag = [key: string, ...values: string[]];

// @public (undocumented)
export interface P2PKVerificationResult {
    // (undocumented)
    eligibleSigners: number;
    // (undocumented)
    lockState: LockState;
    // (undocumented)
    path: P2PKSpendingPath;
    // (undocumented)
    receivedSigners: string[];
    // (undocumented)
    requiredSigners: number;
    // (undocumented)
    success: boolean;
}

// @public
export type P2PKWitness = {
    signatures?: string[];
};

// @public
export function parseHTLCSecret(secret: string | Secret): Secret;

// @public
export function parseP2PKSecret(secret: string | Secret): Secret;

// @public @deprecated (undocumented)
export function parseP2PKSecret(secret: Uint8Array): Secret;

// @public
export function parseSecret(secret: string | Secret): Secret;

// @public @deprecated
export type PartialMeltQuoteResponse = MeltQuoteBolt11Response;

// @public @deprecated
export type PartialMintQuoteResponse = MintQuoteBolt11Response;

// @public (undocumented)
class PaymentRequest_2 {
    constructor(transport?: PaymentRequestTransport[] | undefined, id?: string | undefined, amount?: number | undefined, unit?: string | undefined, mints?: string[] | undefined, description?: string | undefined, singleUse?: boolean, nut10?: NUT10Option | undefined, nut26?: boolean);
    // (undocumented)
    amount?: number | undefined;
    // (undocumented)
    description?: string | undefined;
    // (undocumented)
    static fromEncodedRequest(encodedRequest: string): PaymentRequest_2;
    static fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest_2;
    // (undocumented)
    getTransport(type: PaymentRequestTransportType): PaymentRequestTransport | undefined;
    // (undocumented)
    id?: string | undefined;
    // (undocumented)
    mints?: string[] | undefined;
    // (undocumented)
    nut10?: NUT10Option | undefined;
    // (undocumented)
    nut26: boolean;
    // (undocumented)
    singleUse: boolean;
    toEncodedCreqA(): string;
    toEncodedCreqB(): string;
    // (undocumented)
    toEncodedRequest(): string;
    // (undocumented)
    toRawRequest(): RawPaymentRequest;
    // (undocumented)
    transport?: PaymentRequestTransport[] | undefined;
    // (undocumented)
    unit?: string | undefined;
}
export { PaymentRequest_2 as PaymentRequest }

// @public (undocumented)
export type PaymentRequestPayload = {
    id?: string;
    memo?: string;
    unit: string;
    mint: string;
    proofs: Proof[];
};

// @public (undocumented)
export type PaymentRequestTransport = {
    type: PaymentRequestTransportType;
    target: string;
    tags?: string[][];
};

// @public (undocumented)
export enum PaymentRequestTransportType {
    // (undocumented)
    NOSTR = "nostr",
    // (undocumented)
    POST = "post"
}

// @public (undocumented)
export function pointFromBytes(bytes: Uint8Array): WeierstrassPoint<bigint>;

// @public (undocumented)
export function pointFromHex(hex: string): WeierstrassPoint<bigint>;

// @public
export type PostRestorePayload = {
    outputs: SerializedBlindedMessage[];
};

// @public
export type PostRestoreResponse = {
    outputs: SerializedBlindedMessage[];
    signatures: SerializedBlindedSignature[];
};

// @public
export type PrivKey = Uint8Array | string;

// @public
export type Proof = {
    id: string;
    amount: number;
    secret: string;
    C: string;
    dleq?: SerializedDLEQ;
    p2pk_e?: string;
    witness?: string | P2PKWitness | HTLCWitness;
};

// @public
export type ProofState = {
    Y: string;
    state: CheckStateEnum;
    witness: string | null;
};

// @public (undocumented)
export type RawBlindedMessage = {
    B_: WeierstrassPoint<bigint>;
    r: bigint;
    secret: Uint8Array;
};

// @public (undocumented)
export type RawMintKeys = {
    [k: string]: Uint8Array;
};

// @public (undocumented)
export type RawNUT10Option = {
    k: string;
    d: string;
    t: string[][];
};

// @public (undocumented)
export type RawPaymentRequest = {
    i?: string;
    a?: number;
    u?: string;
    s?: boolean;
    m?: string[];
    d?: string;
    t?: RawTransport[];
    nut10?: RawNUT10Option;
    nut26?: boolean;
};

// @public (undocumented)
export type RawProof = {
    C: WeierstrassPoint<bigint>;
    secret: Uint8Array;
    amount: number;
    id: string;
    witness?: P2PKWitness;
};

// @public (undocumented)
export type RawTransport = {
    t: PaymentRequestTransportType;
    a: string;
    g?: string[][];
};

// @public
export class ReceiveBuilder {
    constructor(wallet: Wallet, token: Token | string);
    asCustom(data: OutputDataLike[]): this;
    asDeterministic(counter?: number, denoms?: number[]): this;
    asFactory(factory: OutputDataFactory, denoms?: number[]): this;
    asP2PK(options: P2PKOptions, denoms?: number[]): this;
    asRandom(denoms?: number[]): this;
    keyset(id: string): this;
    onCountersReserved(cb: OnCountersReserved): this;
    prepare(): Promise<SwapPreview>;
    privkey(k: string | string[]): this;
    proofsWeHave(p: Proof[]): this;
    requireDleq(on?: boolean): this;
    run(): Promise<Proof[]>;
}

// @public
export type ReceiveConfig = {
    keysetId?: string;
    privkey?: string | string[];
    requireDleq?: boolean;
    proofsWeHave?: Proof[];
    onCountersReserved?: OnCountersReserved;
};

// @public (undocumented)
export type RequestArgs = {
    endpoint: string;
    requestBody?: Record<string, unknown>;
    headers?: Record<string, string>;
    logger?: Logger;
};

// @public (undocumented)
export type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;

// @public (undocumented)
export type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;

// @public (undocumented)
export type RestoreConfig = {
    keysetId?: string;
};

// @public (undocumented)
export type RpcSubKinds = 'bolt11_mint_quote' | 'bolt11_melt_quote' | 'proof_state';

// @public (undocumented)
export function sanitizeUrl(url: string): string;

// @public
export const schnorrSignMessage: (message: string, privateKey: PrivKey) => string;

// @public
export const schnorrVerifyMessage: (signature: string, message: string, pubkey: string, throws?: boolean) => boolean;

// @public (undocumented)
export type Secret = [SecretKind, SecretData];

// @public (undocumented)
export interface SecretData {
    // (undocumented)
    data: string;
    // (undocumented)
    nonce: string;
    // (undocumented)
    tags?: string[][];
}

// @public (undocumented)
export type SecretKind = 'P2PK' | 'HTLC' | (string & {});

// @public (undocumented)
export type SecretsPolicy = 'auto' | 'deterministic' | 'random';

// @public (undocumented)
export type SelectProofs = (proofs: Proof[], amountToSend: number, keyChain: KeyChain, includeFees?: boolean, exactMatch?: boolean, logger?: Logger) => SendResponse;

// @public (undocumented)
export const selectProofsRGLI: SelectProofs;

// @public
export class SendBuilder {
    constructor(wallet: Wallet, amount: number, proofs: Proof[]);
    asCustom(data: OutputDataLike[]): this;
    asDeterministic(counter?: number, denoms?: number[]): this;
    asFactory(factory: OutputDataFactory, denoms?: number[]): this;
    asP2PK(options: P2PKOptions, denoms?: number[]): this;
    asRandom(denoms?: number[]): this;
    includeFees(on?: boolean): this;
    keepAsCustom(data: OutputDataLike[]): this;
    keepAsDeterministic(counter?: number, denoms?: number[]): this;
    keepAsFactory(factory: OutputDataFactory, denoms?: number[]): this;
    keepAsP2PK(options: P2PKOptions, denoms?: number[]): this;
    keepAsRandom(denoms?: number[]): this;
    keyset(id: string): this;
    offlineCloseMatch(requireDleq?: boolean): this;
    offlineExactOnly(requireDleq?: boolean): this;
    onCountersReserved(cb: OnCountersReserved): this;
    prepare(): Promise<SwapPreview>;
    privkey(k: string | string[]): this;
    proofsWeHave(p: Proof[]): this;
    run(): Promise<SendResponse>;
}

// @public
export type SendConfig = {
    keysetId?: string;
    privkey?: string | string[];
    includeFees?: boolean;
    proofsWeHave?: Proof[];
    onCountersReserved?: OnCountersReserved;
};

// @public
export type SendOfflineConfig = {
    requireDleq?: boolean;
    includeFees?: boolean;
    exactMatch?: boolean;
};

// @public
export type SendResponse = {
    keep: Proof[];
    send: Proof[];
    serialized?: Array<{
        proof: Proof;
        keep: boolean;
    }>;
};

// @public
export type SerializedBlindedMessage = {
    amount: number;
    B_: string;
    id: string;
};

// @public
export type SerializedBlindedSignature = {
    id: string;
    amount: number;
    C_: string;
    dleq?: SerializedDLEQ;
};

// @public (undocumented)
export type SerializedDLEQ = {
    s: string;
    e: string;
    r?: string;
};

// @public (undocumented)
export type SerializedMintKeys = {
    [k: string]: string;
};

// @public (undocumented)
export type SerializedProof = {
    C: string;
    secret: string;
    amount: number;
    id: string;
    witness?: string;
};

// @public (undocumented)
export function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys;

// @public (undocumented)
export const serializeProof: (proof: RawProof) => SerializedProof;

// @public
export function setGlobalRequestOptions(options: Partial<RequestOptions>): void;

// @public
export interface SharedOutputTypeProps {
    denominations?: number[];
}

// @public (undocumented)
export type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';

// @public (undocumented)
export function signMintQuote(privkey: string, quote: string, blindedMessages: SerializedBlindedMessage[]): string;

// @public
export function signP2PKProof(proof: Proof, privateKey: PrivKey, message?: string): Proof;

// @public
export function signP2PKProofs(proofs: Proof[], privateKey: PrivKey | PrivKey[], logger?: Logger, message?: string): Proof[];

// @public @deprecated
export const signP2PKSecret: (secret: string, privateKey: PrivKey) => string;

// @public (undocumented)
export function sortProofsById(proofs: Proof[]): Proof[];

// @public
export function splitAmount(value: number, keyset: Keys, split?: number[], order?: 'desc' | 'asc'): number[];

// @public
export function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>>;

// @public (undocumented)
export type SubscribeOpts = {
    signal?: AbortSignal;
};

// @public (undocumented)
export type SubscriptionCanceller = () => void;

// @public (undocumented)
export function sumProofs(proofs: Proof[]): number;

// @public
export type SwapMethod = {
    method: string;
    unit: string;
    min_amount: number;
    max_amount: number;
    description?: boolean;
    options?: {
        description?: boolean;
        amountless?: boolean;
    };
};

// @public @deprecated
export type SwapPayload = SwapRequest;

// @public
export type SwapPreview = {
    amount: number;
    fees: number;
    keysetId: string;
    inputs: Proof[];
    sendOutputs?: OutputDataLike[];
    keepOutputs?: OutputDataLike[];
    unselectedProofs?: Proof[];
};

// @public
export type SwapRequest = {
    inputs: Proof[];
    outputs: SerializedBlindedMessage[];
};

// @public
export type SwapResponse = {
    signatures: SerializedBlindedSignature[];
};

// @public
export type SwapTransaction = {
    payload: SwapRequest;
    outputData: OutputDataLike[];
    keepVector: boolean[];
    sortedIndices: number[];
};

// @public
export type Token = {
    mint: string;
    proofs: Proof[];
    memo?: string;
    unit?: string;
};

// @public
export type TokenMetadata = {
    unit: string;
    memo?: string;
    mint: string;
    amount: number;
    incompleteProofs: Array<Omit<Proof, 'id'>>;
};

// @public (undocumented)
export type TokenResponse = {
    access_token?: string;
    token_type?: string;
    expires_in?: number;
    refresh_token?: string;
    id_token?: string;
    scope?: string;
    error?: string;
    error_description?: string;
};

// @public (undocumented)
export function unblindSignature(C_: WeierstrassPoint<bigint>, r: bigint, A: WeierstrassPoint<bigint>): WeierstrassPoint<bigint>;

// @public (undocumented)
export const verifyDLEQProof: (dleq: DLEQ, B_: WeierstrassPoint<bigint>, C_: WeierstrassPoint<bigint>, A: WeierstrassPoint<bigint>) => boolean;

// @public (undocumented)
export const verifyDLEQProof_reblind: (secret: Uint8Array, // secret
dleq: DLEQ, C: WeierstrassPoint<bigint>, // unblinded e-cash signature point
A: WeierstrassPoint<bigint>) => boolean;

// @public
export function verifyHTLCHash(preimage: string, hash: string): boolean;

// @public
export function verifyHTLCSpendingConditions(proof: Proof, logger?: Logger, message?: string): P2PKVerificationResult;

// @public @deprecated (undocumented)
export function verifyKeysetId(keys: MintKeys): boolean;

// @public (undocumented)
export function verifyMintQuoteSignature(pubkey: string, quote: string, blindedMessages: SerializedBlindedMessage[], signature: string): boolean;

// @public @deprecated
export const verifyP2PKSecretSignature: (signature: string, secret: string, pubkey: string) => boolean;

// @public @deprecated (undocumented)
export function verifyP2PKSig(proof: Proof): boolean;

// @public
export function verifyP2PKSpendingConditions(proof: Proof, logger?: Logger, message?: string): P2PKVerificationResult;

// @public (undocumented)
export function verifyProof(proof: RawProof, privKey: Uint8Array): boolean;

// @public
export class Wallet {
    constructor(mint: Mint | string, options?: {
        unit?: string;
        authProvider?: AuthProvider;
        keysetId?: string;
        bip39seed?: Uint8Array;
        secretsPolicy?: SecretsPolicy;
        counterSource?: CounterSource;
        counterInit?: Record<string, number>;
        keys?: MintKeys[] | MintKeys;
        keysets?: MintKeyset[];
        mintInfo?: GetInfoResponse;
        denominationTarget?: number;
        selectProofs?: SelectProofs;
        logger?: Logger;
    });
    batchRestore(gapLimit?: number, batchSize?: number, counter?: number, keysetId?: string): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    bindKeyset(id: string): void;
    // @deprecated (undocumented)
    checkMeltQuote(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response>;
    checkMeltQuoteBolt11(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response>;
    checkMeltQuoteBolt12(quote: string): Promise<MeltQuoteBolt12Response>;
    // @deprecated (undocumented)
    checkMintQuote(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response>;
    checkMintQuoteBolt11(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response>;
    checkMintQuoteBolt12(quote: string): Promise<MintQuoteBolt12Response>;
    checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]>;
    completeMelt<TQuote extends MeltQuoteBaseResponse>(meltPreview: MeltPreview<TQuote> | MeltBlanks<TQuote>, privkey?: string | string[], preferAsync?: boolean): Promise<MeltProofsResponse<TQuote>>;
    completeSwap(swapPreview: SwapPreview, privkey?: string | string[]): Promise<SendResponse>;
    readonly counters: WalletCounters;
    createLockedMintQuote(amount: number, pubkey: string, description?: string): Promise<MintQuoteBolt11Response>;
    // @deprecated (undocumented)
    createMeltQuote(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response>;
    createMeltQuoteBolt11(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response>;
    createMeltQuoteBolt12(offer: string, amountMsat?: number): Promise<MeltQuoteBolt12Response>;
    // @deprecated (undocumented)
    createMintQuote(amount: number, description?: string): Promise<MintQuoteBolt11Response>;
    createMintQuoteBolt11(amount: number, description?: string): Promise<MintQuoteBolt11Response>;
    createMintQuoteBolt12(pubkey: string, options?: {
        amount?: number;
        description?: string;
    }): Promise<MintQuoteBolt12Response>;
    createMultiPathMeltQuote(invoice: string, millisatPartialAmount: number): Promise<MeltQuoteBolt11Response>;
    decodeToken(token: string): Token;
    defaultOutputType(): OutputType;
    getFeesForKeyset(nInputs: number, keysetId: string): number;
    getFeesForProofs(proofs: Proof[]): number;
    getKeyset(id?: string): Keyset;
    getMintInfo(): MintInfo;
    groupProofsByState(proofs: Proof[]): Promise<{
        unspent: Proof[];
        pending: Proof[];
        spent: Proof[];
    }>;
    get keyChain(): KeyChain;
    get keysetId(): string;
    loadMint(forceRefresh?: boolean): Promise<void>;
    loadMintFromCache(mintInfo: GetInfoResponse, cache: KeyChainCache): void;
    // (undocumented)
    get logger(): Logger;
    // @deprecated (undocumented)
    meltProofs(meltQuote: MeltQuoteBolt11Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt11Response>>;
    meltProofsBolt11(meltQuote: MeltQuoteBolt11Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt11Response>>;
    meltProofsBolt12(meltQuote: MeltQuoteBolt12Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt12Response>>;
    readonly mint: Mint;
    // @deprecated (undocumented)
    mintProofs(amount: number, quote: string | MintQuoteBolt11Response, config?: MintProofsConfig, outputType?: OutputType): Promise<Proof[]>;
    mintProofsBolt11(amount: number, quote: string | MintQuoteBolt11Response, config?: MintProofsConfig, outputType?: OutputType): Promise<Proof[]>;
    mintProofsBolt12(amount: number, quote: MintQuoteBolt12Response, privkey: string, config?: {
        keysetId?: string;
    }, outputType?: OutputType): Promise<Proof[]>;
    readonly on: WalletEvents;
    readonly ops: WalletOps;
    prepareMelt<TQuote extends MeltQuoteBaseResponse>(method: string, meltQuote: TQuote, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltPreview<TQuote>>;
    prepareSwapToReceive(token: Token | string, config?: ReceiveConfig, outputType?: OutputType): Promise<SwapPreview>;
    prepareSwapToSend(amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig): Promise<SwapPreview>;
    receive(token: Token | string, config?: ReceiveConfig, outputType?: OutputType): Promise<Proof[]>;
    restore(start: number, count: number, config?: RestoreConfig): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    selectProofsToSend(proofs: Proof[], amountToSend: number, includeFees?: boolean, exactMatch?: boolean): SendResponse;
    send(amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig): Promise<SendResponse>;
    sendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse;
    signP2PKProofs(proofs: Proof[], privkey: string | string[], outputData?: OutputDataLike[], quoteId?: string): Proof[];
    // @deprecated (undocumented)
    readonly swap: (amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig) => Promise<SendResponse>;
    get unit(): string;
    withKeyset(id: string, opts?: {
        counterSource?: CounterSource;
    }): Wallet;
}

// @public
export class WalletCounters {
    constructor(src: CounterSource);
    advanceToAtLeast(keysetId: string, minNext: number): Promise<void>;
    peekNext(keysetId: string): Promise<number>;
    setNext(keysetId: string, next: number): Promise<void>;
    snapshot(): Promise<Record<string, number>>;
}

// @public (undocumented)
export class WalletEvents {
    constructor(wallet: Wallet);
    countersReserved(cb: (payload: OperationCounters) => void, opts?: SubscribeOpts): SubscriptionCanceller;
    group(): SubscriptionCanceller & {
        add: (c: CancellerLike) => CancellerLike;
        cancelled: boolean;
    };
    // @deprecated
    meltBlanksCreated(cb: (payload: MeltBlanks<MeltQuoteBaseResponse>) => void, opts?: SubscribeOpts): SubscriptionCanceller;
    meltQuotePaid(id: string, cb: (p: MeltQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
    meltQuoteUpdates(ids: string[], cb: (p: MeltQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
    mintQuotePaid(id: string, cb: (p: MintQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
    mintQuoteUpdates(ids: string[], cb: (p: MintQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
    onceAnyMintPaid(ids: string[], opts?: {
        signal?: AbortSignal;
        timeoutMs?: number;
        failOnError?: boolean;
    }): Promise<{
        id: string;
        quote: MintQuoteBolt11Response;
    }>;
    onceMeltPaid(id: string, opts?: {
        signal?: AbortSignal;
        timeoutMs?: number;
    }): Promise<MeltQuoteBolt11Response>;
    onceMintPaid(id: string, opts?: {
        signal?: AbortSignal;
        timeoutMs?: number;
    }): Promise<MintQuoteBolt11Response>;
    proofStatesStream<T = unknown>(proofs: Proof[], opts?: {
        signal?: AbortSignal;
        maxBuffer?: number;
        drop?: 'oldest' | 'newest';
        onDrop?: (payload: T) => void;
    }): AsyncIterable<T>;
    proofStateUpdates(proofs: Proof[], cb: (payload: ProofState & {
        proof: Proof;
    }) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
}

// @public
export class WalletOps {
    constructor(wallet: Wallet);
    // (undocumented)
    meltBolt11(quote: MeltQuoteBolt11Response, proofs: Proof[]): MeltBuilder<MeltQuoteBolt11Response>;
    // (undocumented)
    meltBolt12(quote: MeltQuoteBolt12Response, proofs: Proof[]): MeltBuilder<MeltQuoteBolt11Response>;
    // (undocumented)
    mintBolt11(amount: number, quote: MintQuoteFor<'bolt11'>): MintBuilder<"bolt11", true>;
    // (undocumented)
    mintBolt12(amount: number, quote: MintQuoteFor<'bolt12'>): MintBuilder<"bolt12", false>;
    // (undocumented)
    receive(token: Token | string): ReceiveBuilder;
    // (undocumented)
    send(amount: number, proofs: Proof[]): SendBuilder;
}

// @public
export type WebSocketSupport = {
    method: string;
    unit: string;
    commands: string[];
};

// @public @deprecated (undocumented)
export type WellKnownSecret = 'P2PK';

// @public (undocumented)
export class WSConnection {
    constructor(url: string, logger?: Logger);
    // (undocumented)
    get activeSubscriptions(): string[];
    // (undocumented)
    addSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void): void;
    cancelSubscription<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void, errorCallback?: (e: Error) => void): void;
    // (undocumented)
    close(): void;
    // @deprecated (undocumented)
    closeSubscription(subId: string): void;
    // (undocumented)
    connect(timeoutMs?: number): Promise<void>;
    // (undocumented)
    createSubscription<TPayload = unknown>(params: Omit<JsonRpcReqParams, 'subId'>, callback: (payload: TPayload) => void, errorCallback: (e: Error) => void): string;
    // (undocumented)
    ensureConnection(timeoutMs?: number): Promise<void>;
    // (undocumented)
    onClose(callback: (e: CloseEvent) => void): void;
    // (undocumented)
    sendRequest(method: 'subscribe', params: JsonRpcReqParams): void;
    // (undocumented)
    sendRequest(method: 'unsubscribe', params: {
        subId: string;
    }): void;
    // (undocumented)
    setLogger(logger: Logger): void;
    // (undocumented)
    readonly url: URL;
}

// (No @packageDocumentation comment for this package)

```
