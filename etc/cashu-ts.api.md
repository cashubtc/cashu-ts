## API Report File for "@cashu/cashu-ts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CashuAuthMint } from './auth.js';
import { CashuAuthWallet } from './auth.js';
import { getBlindedAuthToken } from './auth.js';
import { getEncodedAuthToken } from './auth.js';
import { GetInfoResponse as GetInfoResponse_2 } from './types.js';
import { JsonRpcReqParams as JsonRpcReqParams_2 } from './model/types.js';
import { Keys as Keys_2 } from './model/types.js';
import { MintActiveKeys as MintActiveKeys_2 } from './types.js';
import { MintAllKeysets as MintAllKeysets_2 } from './types.js';
import { MintContactInfo as MintContactInfo_2 } from './types';
import { MintKeys as MintKeys_2 } from './types.js';
import { MintKeys as MintKeys_3 } from './model/types.js';
import { MintKeyset as MintKeyset_2 } from './types.js';
import { MintKeyset as MintKeyset_3 } from './model/types.js';
import { MPPMethod as MPPMethod_2 } from './types.js';
import { NUT10Option as NUT10Option_2 } from './types.js';
import { PaymentRequestTransport as PaymentRequestTransport_2 } from './types.js';
import { PaymentRequestTransportType as PaymentRequestTransportType_2 } from './types.js';
import { Proof as Proof_2 } from './types.js';
import { Proof as Proof_3 } from './model/types.js';
import { RawPaymentRequest as RawPaymentRequest_2 } from './types.js';
import { SerializedBlindedMessage as SerializedBlindedMessage_2 } from './types.js';
import { SerializedBlindedSignature as SerializedBlindedSignature_2 } from './types.js';
import { SwapMethod as SwapMethod_2 } from './types.js';
import { Token as Token_2 } from './model/types.js';
import { WebSocketSupport as WebSocketSupport_2 } from './types.js';

// @public
export type AmountlessOption = {
    amount_msat: number;
};

// @public
export type ApiError = {
    error?: string;
    code?: number;
    detail?: string;
};

// @public
export type BlindAuthMintPayload = {
    outputs: SerializedBlindedMessage[];
};

// @public
export type BlindAuthMintResponse = {
    signatures: SerializedBlindedSignature[];
} & ApiError;

// @public
export type Bolt12MeltQuotePayload = MeltQuotePayload;

// @public
export type Bolt12MeltQuoteResponse = MeltQuoteResponse;

// @public
export type Bolt12MintQuotePayload = Omit<MintQuotePayload, 'amount'> & {
    amount?: number;
    pubkey: string;
};

// @public
export type Bolt12MintQuoteResponse = {
    quote: string;
    request: string;
    amount: number | null;
    unit: string;
    expiry: number | null;
    pubkey: string;
    amount_paid: number;
    amount_issued: number;
};

export { CashuAuthMint }

export { CashuAuthWallet }

// @public
export class CashuMint {
    // Warning: (ae-forgotten-export) The symbol "request" needs to be exported by the entry point index.d.ts
    constructor(_mintUrl: string, _customRequest?: typeof request | undefined, authTokenGetter?: () => Promise<string>, options?: {
        logger?: Logger;
    });
    static check(mintUrl: string, checkPayload: CheckStatePayload, customRequest?: typeof request): Promise<CheckStateResponse>;
    check(checkPayload: CheckStatePayload): Promise<CheckStateResponse>;
    static checkMeltQuote(mintUrl: string, quote: string, customRequest?: typeof request, blindAuthToken?: string, logger?: Logger): Promise<PartialMeltQuoteResponse>;
    checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;
    static checkMeltQuoteBolt12(mintUrl: string, quote: string, customRequest?: typeof request, blindAuthToken?: string): Promise<Bolt12MeltQuoteResponse>;
    checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse>;
    static checkMintQuote(mintUrl: string, quote: string, customRequest?: typeof request, blindAuthToken?: string, logger?: Logger): Promise<PartialMintQuoteResponse>;
    checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;
    static checkMintQuoteBolt12(mintUrl: string, quote: string, customRequest?: typeof request, blindAuthToken?: string): Promise<Bolt12MintQuoteResponse>;
    checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse>;
    connectWebSocket(): Promise<void>;
    static createMeltQuote(mintUrl: string, meltQuotePayload: MeltQuotePayload, customRequest?: typeof request, blindAuthToken?: string, logger?: Logger): Promise<PartialMeltQuoteResponse>;
    createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse>;
    static createMeltQuoteBolt12(mintUrl: string, meltQuotePayload: MeltQuotePayload, customRequest?: typeof request, blindAuthToken?: string): Promise<Bolt12MeltQuoteResponse>;
    createMeltQuoteBolt12(meltQuotePayload: MeltQuotePayload): Promise<Bolt12MeltQuoteResponse>;
    static createMintQuote(mintUrl: string, mintQuotePayload: MintQuotePayload, customRequest?: typeof request, blindAuthToken?: string, logger?: Logger): Promise<PartialMintQuoteResponse>;
    createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse>;
    static createMintQuoteBolt12(mintUrl: string, mintQuotePayload: Bolt12MintQuotePayload, customRequest?: typeof request, blindAuthToken?: string): Promise<Bolt12MintQuoteResponse>;
    createMintQuoteBolt12(mintQuotePayload: Bolt12MintQuotePayload): Promise<Bolt12MintQuoteResponse>;
    disconnectWebSocket(): void;
    static getInfo(mintUrl: string, customRequest?: typeof request, logger?: Logger): Promise<GetInfoResponse>;
    getInfo(): Promise<GetInfoResponse>;
    static getKeys(mintUrl: string, keysetId?: string, customRequest?: typeof request): Promise<MintActiveKeys>;
    getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys>;
    static getKeySets(mintUrl: string, customRequest?: typeof request): Promise<MintAllKeysets>;
    getKeySets(): Promise<MintAllKeysets>;
    // Warning: (ae-forgotten-export) The symbol "MintInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getLazyMintInfo(): Promise<MintInfo>;
    // (undocumented)
    handleBlindAuth(path: string): Promise<string | undefined>;
    static melt(mintUrl: string, meltPayload: MeltPayload, customRequest?: typeof request, blindAuthToken?: string, logger?: Logger): Promise<PartialMeltQuoteResponse>;
    melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse>;
    static meltBolt12(mintUrl: string, meltPayload: MeltPayload, customRequest?: typeof request, blindAuthToken?: string): Promise<Bolt12MeltQuoteResponse>;
    meltBolt12(meltPayload: MeltPayload): Promise<Bolt12MeltQuoteResponse>;
    static mint(mintUrl: string, mintPayload: MintPayload, customRequest?: typeof request, blindAuthToken?: string): Promise<MintResponse>;
    mint(mintPayload: MintPayload): Promise<MintResponse>;
    static mintBolt12(mintUrl: string, mintPayload: MintPayload, customRequest?: typeof request, blindAuthToken?: string): Promise<MintResponse>;
    mintBolt12(mintPayload: MintPayload): Promise<MintResponse>;
    // (undocumented)
    get mintUrl(): string;
    // (undocumented)
    static restore(mintUrl: string, restorePayload: PostRestorePayload, customRequest?: typeof request): Promise<PostRestoreResponse>;
    // (undocumented)
    restore(restorePayload: {
        outputs: SerializedBlindedMessage[];
    }): Promise<PostRestoreResponse>;
    static swap(mintUrl: string, swapPayload: SwapPayload, customRequest?: typeof request, blindAuthToken?: string): Promise<SwapResponse>;
    swap(swapPayload: SwapPayload): Promise<SwapResponse>;
    // Warning: (ae-forgotten-export) The symbol "WSConnection" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get webSocketConnection(): WSConnection | undefined;
}

// @public
export class CashuWallet {
    constructor(mint: CashuMint, options?: {
        unit?: string;
        keys?: MintKeys[] | MintKeys;
        keysets?: MintKeyset[];
        mintInfo?: GetInfoResponse;
        bip39seed?: Uint8Array;
        denominationTarget?: number;
        keepFactory?: OutputDataFactory;
        logger?: Logger;
    });
    batchRestore(gapLimit?: number, batchSize?: number, counter?: number, keysetId?: string): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;
    // (undocumented)
    checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;
    // (undocumented)
    checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse>;
    checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;
    // (undocumented)
    checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;
    checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse>;
    checkProofsStates(proofs: Proof[]): Promise<ProofState[]>;
    createLockedMintQuote(amount: number, pubkey: string, description?: string): Promise<LockedMintQuoteResponse>;
    createMeltQuote(invoice: string): Promise<MeltQuoteResponse>;
    createMeltQuoteBolt12(offer: string, amountMsat?: number): Promise<Bolt12MeltQuoteResponse>;
    createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse>;
    createMintQuoteBolt12(pubkey: string, options?: {
        amount?: number;
        description?: string;
    }): Promise<Bolt12MintQuoteResponse>;
    createMultiPathMeltQuote(invoice: string, millisatPartialAmount: number): Promise<MeltQuoteResponse>;
    getActiveKeyset(keysets: MintKeyset[]): MintKeyset;
    getAllKeys(): Promise<MintKeys[]>;
    getFeesForKeyset(nInputs: number, keysetId: string): number;
    getFeesForProofs(proofs: Proof[]): number;
    getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys>;
    getKeySets(): Promise<MintKeyset[]>;
    getMintInfo(): Promise<MintInfo>;
    // (undocumented)
    get keys(): Map<string, MintKeys>;
    // (undocumented)
    get keysetId(): string;
    set keysetId(keysetId: string);
    // (undocumented)
    get keysets(): MintKeyset[];
    lazyGetMintInfo(): Promise<MintInfo>;
    loadMint(): Promise<void>;
    meltProofs(meltQuote: MeltQuoteResponse, proofsToSend: Proof[], options?: MeltProofOptions): Promise<MeltProofsResponse>;
    meltProofsBolt12(meltQuote: Bolt12MeltQuoteResponse, proofsToSend: Proof[], options?: MeltProofOptions): Promise<{
        quote: Bolt12MeltQuoteResponse;
        change: Proof[];
    }>;
    // (undocumented)
    mint: CashuMint;
    // (undocumented)
    get mintInfo(): MintInfo;
    mintProofs(amount: number, quote: MintQuoteResponse, options: MintProofOptions & {
        privateKey: string;
    }): Promise<Proof[]>;
    // (undocumented)
    mintProofs(amount: number, quote: string, options?: MintProofOptions): Promise<Proof[]>;
    mintProofsBolt12(amount: number, quote: Bolt12MintQuoteResponse, privateKey: string, options?: MintProofOptions): Promise<Proof[]>;
    onMeltQuotePaid(quoteId: string, callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMeltQuoteUpdates(quoteIds: string[], callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMintQuotePaid(quoteId: string, callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    // Warning: (ae-forgotten-export) The symbol "SubscriptionCanceller" needs to be exported by the entry point index.d.ts
    onMintQuoteUpdates(quoteIds: string[], callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onProofStateUpdates(proofs: Proof[], callback: (payload: ProofState & {
        proof: Proof;
    }) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    receive(token: string | Token, options?: ReceiveOptions): Promise<Proof[]>;
    restore(start: number, count: number, options?: RestoreOptions): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    selectProofsToSend(proofs: Proof[], amountToSend: number, includeFees?: boolean): SendResponse;
    send(amount: number, proofs: Proof[], options?: SendOptions): Promise<SendResponse>;
    swap(amount: number, proofs: Proof[], options?: SwapOptions): Promise<SendResponse>;
    // (undocumented)
    get unit(): string;
}

// @public
export const CheckStateEnum: {
    readonly UNSPENT: "UNSPENT";
    readonly PENDING: "PENDING";
    readonly SPENT: "SPENT";
};

// @public (undocumented)
export type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];

// @public
export type CheckStatePayload = {
    Ys: string[];
};

// @public
export type CheckStateResponse = {
    states: ProofState[];
} & ApiError;

// @public
export class ConsoleLogger implements Logger {
    constructor(minLevel?: LogLevel);
    // (undocumented)
    debug(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    error(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    fatal(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    info(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    static readonly SEVERITY: Record<LogLevel, number>;
    // (undocumented)
    trace(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    warn(message: string, context?: Record<string, unknown>): void;
}

// @public (undocumented)
export function decodePaymentRequest(paymentRequest: string): PaymentRequest_2;

// @public
export const DEFAULT_OUTPUT: {
    type: "random";
};

// @public
export const DEFAULT_OUTPUT_CONFIG: OutputConfig;

// @public
export type DeprecatedToken = {
    token: TokenEntry[];
    memo?: string;
    unit?: string;
};

// @public
export function deriveKeysetId(keys: Keys_2, unit?: string, expiry?: number, versionByte?: number, isDeprecatedBase64?: boolean): string;

export { getBlindedAuthToken }

// @public
export function getDecodedToken(tokenString: string, keysets?: MintKeyset_3[]): Token_2;

// @public (undocumented)
export function getDecodedTokenBinary(bytes: Uint8Array): Token_2;

export { getEncodedAuthToken }

// @public
export function getEncodedToken(token: Token_2, opts?: {
    version?: 3 | 4;
    removeDleq?: boolean;
}): string;

// @public (undocumented)
export function getEncodedTokenBinary(token: Token_2): Uint8Array;

// @public (undocumented)
export function getEncodedTokenV4(token: Token_2, removeDleq?: boolean): string;

// @public
export type GetInfoResponse = {
    name: string;
    pubkey: string;
    version: string;
    description?: string;
    description_long?: string;
    icon_url?: string;
    contact: MintContactInfo[];
    nuts: {
        '4': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '5': {
            methods: SwapMethod[];
            disabled: boolean;
        };
        '7'?: {
            supported: boolean;
        };
        '8'?: {
            supported: boolean;
        };
        '9'?: {
            supported: boolean;
        };
        '10'?: {
            supported: boolean;
        };
        '11'?: {
            supported: boolean;
        };
        '12'?: {
            supported: boolean;
        };
        '14'?: {
            supported: boolean;
        };
        '15'?: {
            methods: MPPMethod[];
        };
        '17'?: {
            supported: WebSocketSupport[];
        };
        '20'?: {
            supported: boolean;
        };
        '22'?: {
            bat_max_mint: number;
            protected_endpoints: Array<{
                method: 'GET' | 'POST';
                path: string;
            }>;
        };
    };
    motd?: string;
};

// @public
export function hasValidDleq(proof: Proof_3, keyset: MintKeys_3): boolean;

// @public
export type HTLCWitness = {
    preimage: string;
    signatures?: string[];
};

// @public
export class HttpResponseError extends Error {
    constructor(message: string, status: number);
    // (undocumented)
    status: number;
}

// @public (undocumented)
export function injectWebSocketImpl(ws: typeof WebSocket): void;

// @public (undocumented)
export type InvoiceData = {
    paymentRequest: string;
    amountInSats?: number;
    amountInMSats?: number;
    timestamp?: number;
    paymentHash?: string;
    memo?: string;
    expiry?: number;
};

// @public (undocumented)
export type JsonRpcErrorObject = {
    code: number;
    message: string;
    data?: unknown;
};

// Warning: (ae-forgotten-export) The symbol "JsonRpcRequest" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "JsonRpcSuccess" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "JsonRpcError" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type JsonRpcMessage = JsonRpcRequest | JsonRpcNotification | JsonRpcSuccess | JsonRpcError;

// @public (undocumented)
export type JsonRpcNotification = {
    jsonrpc: '2.0';
    method: string;
    params?: JsonRpcParams;
};

// @public (undocumented)
export type JsonRpcReqParams = {
    kind: RpcSubKinds;
    filters: string[];
    subId: string;
};

// @public (undocumented)
export class KeyChain {
    constructor(mint: Mint, unit: string, cachedKeysets?: MintKeyset_2[] | MintAllKeysets_2, cachedKeys?: MintKeys_2[] | MintKeys_2 | MintActiveKeys_2);
    getActiveKeyset(): Keyset;
    getAllKeys(): MintKeys_2[];
    getCache(): {
        keysets: MintKeyset_2[];
        keys: MintKeys_2[];
        unit: string;
        mintUrl: string;
    };
    getKeys(id?: string): MintKeys_2;
    // Warning: (ae-forgotten-export) The symbol "Keyset" needs to be exported by the entry point index.d.ts
    getKeyset(id: string): Keyset;
    getKeysetList(): Keyset[];
    getKeySets(): MintKeyset_2[];
    init(forceRefresh?: boolean): Promise<void>;
}

// @public
export type Keys = {
    [amount: number]: string;
};

// @public (undocumented)
export type LockedMintQuote = {
    id: string;
    privkey: string;
};

// @public (undocumented)
export type LockedMintQuoteResponse = MintQuoteResponse & {
    pubkey: string;
};

// @public (undocumented)
export interface Logger {
    // (undocumented)
    debug(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    error(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    fatal(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    info(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    trace(message: string, context?: Record<string, unknown>): void;
    // (undocumented)
    warn(message: string, context?: Record<string, unknown>): void;
}

// @public
export const LogLevel: {
    readonly FATAL: "FATAL";
    readonly ERROR: "ERROR";
    readonly WARN: "WARN";
    readonly INFO: "INFO";
    readonly DEBUG: "DEBUG";
    readonly TRACE: "TRACE";
};

// @public
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];

// @public
export type MeltPayload = {
    quote: string;
    inputs: Proof[];
    outputs: SerializedBlindedMessage[];
};

// @public (undocumented)
export type MeltProofOptions = {
    keysetId?: string;
    counter?: number;
    privkey?: string;
};

// @public
export type MeltProofsConfig = {
    keysetId?: string;
    privkey?: string;
};

// @public
export type MeltProofsResponse = {
    quote: MeltQuoteResponse;
    change: Proof[];
};

// @public
export type MeltQuoteOptions = {
    mpp?: MPPOption;
    amountless?: AmountlessOption;
};

// @public
export type MeltQuotePayload = {
    unit: string;
    request: string;
    options?: MeltQuoteOptions;
};

// @public (undocumented)
export type MeltQuoteResponse = PartialMeltQuoteResponse & {
    request: string;
    unit: string;
};

// @public (undocumented)
export const MeltQuoteState: {
    readonly UNPAID: "UNPAID";
    readonly PENDING: "PENDING";
    readonly PAID: "PAID";
};

// @public (undocumented)
export type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];

// @public
export class Mint {
    constructor(_mintUrl: string, customRequest?: typeof request, authTokenGetter?: () => Promise<string>, options?: {
        logger?: Logger;
    });
    check(checkPayload: CheckStatePayload, customRequest?: typeof request): Promise<CheckStateResponse>;
    checkMeltQuote(quote: string, customRequest?: typeof request): Promise<PartialMeltQuoteResponse>;
    checkMeltQuoteBolt12(quote: string, customRequest?: typeof request): Promise<Bolt12MeltQuoteResponse>;
    checkMintQuote(quote: string, customRequest?: typeof request): Promise<PartialMintQuoteResponse>;
    checkMintQuoteBolt12(quote: string, customRequest?: typeof request): Promise<Bolt12MintQuoteResponse>;
    connectWebSocket(): Promise<void>;
    createMeltQuote(meltQuotePayload: MeltQuotePayload, customRequest?: typeof request): Promise<PartialMeltQuoteResponse>;
    createMeltQuoteBolt12(meltQuotePayload: MeltQuotePayload, customRequest?: typeof request): Promise<Bolt12MeltQuoteResponse>;
    createMintQuote(mintQuotePayload: MintQuotePayload, customRequest?: typeof request): Promise<PartialMintQuoteResponse>;
    createMintQuoteBolt12(mintQuotePayload: Bolt12MintQuotePayload, customRequest?: typeof request): Promise<Bolt12MintQuoteResponse>;
    disconnectWebSocket(): void;
    getInfo(customRequest?: typeof request): Promise<GetInfoResponse>;
    getKeys(keysetId?: string, mintUrl?: string, customRequest?: typeof request): Promise<MintActiveKeys>;
    getKeySets(customRequest?: typeof request): Promise<MintAllKeysets>;
    getLazyMintInfo(): Promise<MintInfo>;
    handleBlindAuth(path: string): Promise<string | undefined>;
    melt(meltPayload: MeltPayload, customRequest?: typeof request): Promise<PartialMeltQuoteResponse>;
    meltBolt12(meltPayload: MeltPayload, customRequest?: typeof request): Promise<Bolt12MeltQuoteResponse>;
    mint(mintPayload: MintPayload, customRequest?: typeof request): Promise<MintResponse>;
    mintBolt12(mintPayload: MintPayload, customRequest?: typeof request): Promise<MintResponse>;
    // (undocumented)
    get mintUrl(): string;
    restore(restorePayload: PostRestorePayload, customRequest?: typeof request): Promise<PostRestoreResponse>;
    swap(swapPayload: SwapPayload, customRequest?: typeof request): Promise<SwapResponse>;
    // (undocumented)
    get webSocketConnection(): WSConnection | undefined;
}

// @public
export type MintActiveKeys = {
    keysets: MintKeys[];
};

// @public
export type MintAllKeysets = {
    keysets: MintKeyset[];
};

// @public (undocumented)
export type MintContactInfo = {
    method: string;
    info: string;
};

// @public
export type MintKeys = {
    id: string;
    unit: string;
    final_expiry?: number;
    keys: Keys;
};

// @public
export type MintKeyset = {
    id: string;
    unit: string;
    active: boolean;
    input_fee_ppk?: number;
    final_expiry?: number;
};

// @public
export class MintOperationError extends HttpResponseError {
    constructor(code: number, detail: string);
    // (undocumented)
    code: number;
}

// @public
export type MintPayload = {
    quote: string;
    outputs: SerializedBlindedMessage[];
    signature?: string;
};

// @public (undocumented)
export type MintProofOptions = {
    keysetId?: string;
    outputAmounts?: OutputAmounts;
    proofsWeHave?: Proof[];
    counter?: number;
    pubkey?: string;
    outputData?: OutputDataLike[] | OutputDataFactory;
    p2pk?: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    };
};

// @public
export type MintProofsConfig = {
    keysetId?: string;
    privkey?: string;
};

// @public
export type MintQuotePayload = {
    unit: string;
    amount: number;
    description?: string;
    pubkey?: string;
};

// @public (undocumented)
export type MintQuoteResponse = PartialMintQuoteResponse & {
    amount: number;
    unit: string;
};

// @public (undocumented)
export const MintQuoteState: {
    readonly UNPAID: "UNPAID";
    readonly PAID: "PAID";
    readonly ISSUED: "ISSUED";
};

// @public (undocumented)
export type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];

// @public
export type MintResponse = {
    signatures: SerializedBlindedSignature[];
} & ApiError;

// @public
export type MPPMethod = {
    method: string;
    unit: string;
};

// @public
export type MPPOption = {
    amount: number;
};

// @public
export class NetworkError extends Error {
    constructor(message: string);
}

// @public
export type NUT10Option = {
    kind: string;
    data: string;
    tags: string[][];
};

// @public (undocumented)
export type OutputAmounts = {
    sendAmounts: number[];
    keepAmounts?: number[];
};

// @public
export interface OutputConfig {
    // (undocumented)
    keep?: OutputType;
    // (undocumented)
    send: OutputType;
}

// @public (undocumented)
export class OutputData implements OutputDataLike {
    constructor(blindedMessage: SerializedBlindedMessage_2, blidingFactor: bigint, secret: Uint8Array);
    // (undocumented)
    blindedMessage: SerializedBlindedMessage_2;
    // (undocumented)
    blindingFactor: bigint;
    // (undocumented)
    static createDeterministicData(amount: number, seed: Uint8Array, counter: number, keyset: MintKeys_2, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createP2PKData(p2pk: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    }, amount: number, keyset: MintKeys_2, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createRandomData(amount: number, keyset: MintKeys_2, customSplit?: number[]): OutputData[];
    // (undocumented)
    static createSingleDeterministicData(amount: number, seed: Uint8Array, counter: number, keysetId: string): OutputData;
    // (undocumented)
    static createSingleP2PKData(p2pk: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    }, amount: number, keysetId: string): OutputData;
    // (undocumented)
    static createSingleRandomData(amount: number, keysetId: string): OutputData;
    // (undocumented)
    secret: Uint8Array;
    static sumOutputAmounts(outputs: OutputDataLike[]): number;
    // (undocumented)
    toProof(sig: SerializedBlindedSignature_2, keyset: MintKeys_2): Proof_2;
}

// @public
export type OutputType = ({
    type: 'random';
} & SharedOutputTypeProps) | ({
    type: 'deterministic';
    counter: number;
} & SharedOutputTypeProps) | ({
    type: 'p2pk';
    options: P2PKOptions;
} & SharedOutputTypeProps) | ({
    type: 'factory';
    factory: OutputDataFactory;
} & SharedOutputTypeProps) | {
    type: 'custom';
    data: OutputData[];
};

// @public
export type P2PKOptions = {
    pubkey: string | string[];
    locktime?: number;
    refundKeys?: string[];
    requiredSignatures?: number;
    requiredRefundSignatures?: number;
};

// @public
export type P2PKWitness = {
    signatures?: string[];
};

// @public
export type PartialMeltQuoteResponse = {
    quote: string;
    amount: number;
    fee_reserve: number;
    state: MeltQuoteState;
    expiry: number;
    payment_preimage: string | null;
    change?: SerializedBlindedSignature[];
    request?: string;
    unit?: string;
} & ApiError;

// @public
export type PartialMintQuoteResponse = {
    request: string;
    quote: string;
    state: MintQuoteState;
    expiry: number;
    pubkey?: string;
    unit?: string;
    amount?: number;
} & ApiError;

// @public
export type PaymentPayload = {
    pr: string;
    proofs: Proof[];
};

// @public (undocumented)
class PaymentRequest_2 {
    constructor(transport?: PaymentRequestTransport_2[] | undefined, id?: string | undefined, amount?: number | undefined, unit?: string | undefined, mints?: string[] | undefined, description?: string | undefined, singleUse?: boolean, nut10?: NUT10Option_2 | undefined);
    // (undocumented)
    amount?: number | undefined;
    // (undocumented)
    description?: string | undefined;
    // (undocumented)
    static fromEncodedRequest(encodedRequest: string): PaymentRequest_2;
    // (undocumented)
    static fromRawRequest(rawPaymentRequest: RawPaymentRequest_2): PaymentRequest_2;
    // (undocumented)
    getTransport(type: PaymentRequestTransportType_2): PaymentRequestTransport_2 | undefined;
    // (undocumented)
    id?: string | undefined;
    // (undocumented)
    mints?: string[] | undefined;
    // (undocumented)
    nut10?: NUT10Option_2 | undefined;
    // (undocumented)
    singleUse: boolean;
    // (undocumented)
    toEncodedRequest(): string;
    // (undocumented)
    toRawRequest(): RawPaymentRequest_2;
    // (undocumented)
    transport?: PaymentRequestTransport_2[] | undefined;
    // (undocumented)
    unit?: string | undefined;
}
export { PaymentRequest_2 as PaymentRequest }

// @public (undocumented)
export type PaymentRequestPayload = {
    id?: string;
    memo?: string;
    unit: string;
    mint: string;
    proofs: Proof[];
};

// @public (undocumented)
export type PaymentRequestTransport = {
    type: PaymentRequestTransportType;
    target: string;
    tags?: string[][];
};

// @public (undocumented)
export enum PaymentRequestTransportType {
    // (undocumented)
    NOSTR = "nostr",
    // (undocumented)
    POST = "post"
}

// @public
export type PostRestorePayload = {
    outputs: SerializedBlindedMessage[];
};

// @public
export type PostRestoreResponse = {
    outputs: SerializedBlindedMessage[];
    signatures: SerializedBlindedSignature[];
};

// @public
export type Proof = {
    id: string;
    amount: number;
    secret: string;
    C: string;
    dleq?: SerializedDLEQ;
    witness?: string | P2PKWitness | HTLCWitness;
};

// @public
export type ProofState = {
    Y: string;
    state: CheckStateEnum;
    witness: string | null;
};

// @public (undocumented)
export type RawNUT10Option = {
    k: string;
    d: string;
    t: string[][];
};

// @public (undocumented)
export type RawPaymentRequest = {
    i?: string;
    a?: number;
    u?: string;
    s?: boolean;
    m?: string[];
    d?: string;
    t?: RawTransport[];
    nut10?: RawNUT10Option;
};

// @public (undocumented)
export type RawTransport = {
    t: PaymentRequestTransportType;
    a: string;
    g?: string[][];
};

// @public
export type ReceiveConfig = {
    keysetId?: string;
    privkey?: string;
    requireDleq?: boolean;
};

// @public (undocumented)
export type ReceiveOptions = {
    keysetId?: string;
    outputAmounts?: OutputAmounts;
    proofsWeHave?: Proof[];
    counter?: number;
    pubkey?: string;
    privkey?: string;
    requireDleq?: boolean;
    outputData?: OutputDataLike[] | OutputDataFactory;
    p2pk?: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    };
};

// @public
export type ReceiveResponse = {
    token: Token;
    tokensWithErrors: Token | undefined;
};

// @public
export type ReceiveTokenEntryResponse = {
    proofs: Proof[];
};

// @public (undocumented)
export type RestoreOptions = {
    keysetId?: string;
};

// @public (undocumented)
export type RpcSubId = string | number | null;

// @public
export type SendConfig = {
    keysetId?: string;
    privkey?: string;
    includeFees?: boolean;
};

// @public (undocumented)
export type SendOptions = {
    outputAmounts?: OutputAmounts;
    proofsWeHave?: Proof[];
    counter?: number;
    pubkey?: string;
    privkey?: string;
    keysetId?: string;
    offline?: boolean;
    includeFees?: boolean;
    includeDleq?: boolean;
    outputData?: {
        send?: OutputDataLike[] | OutputDataFactory;
        keep?: OutputDataLike[] | OutputDataFactory;
    };
    p2pk?: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    };
};

// @public
export type SendResponse = {
    keep: Proof[];
    send: Proof[];
    serialized?: Array<{
        proof: Proof;
        keep: boolean;
    }>;
};

// @public
export type SerializedBlindedMessage = {
    amount: number;
    B_: string;
    id: string;
};

// @public
export type SerializedBlindedSignature = {
    id: string;
    amount: number;
    C_: string;
    dleq?: SerializedDLEQ;
};

// @public (undocumented)
export type SerializedDLEQ = {
    s: string;
    e: string;
    r?: string;
};

// Warning: (ae-forgotten-export) The symbol "RequestOptions" needs to be exported by the entry point index.d.ts
//
// @public
export function setGlobalRequestOptions(options: Partial<RequestOptions>): void;

// @public
export interface SharedOutputTypeProps {
    proofsWeHave?: Proof[];
    splitAmounts?: number[];
}

// @public
export type SwapMethod = {
    method: string;
    unit: string;
    min_amount: number;
    max_amount: number;
    options?: {
        description?: boolean;
    };
};

// @public (undocumented)
export type SwapOptions = {
    outputAmounts?: OutputAmounts;
    proofsWeHave?: Proof[];
    counter?: number;
    pubkey?: string;
    privkey?: string;
    keysetId?: string;
    includeFees?: boolean;
    outputData?: {
        send?: OutputDataLike[] | OutputDataFactory;
        keep?: OutputDataLike[] | OutputDataFactory;
    };
    p2pk?: {
        pubkey: string | string[];
        locktime?: number;
        refundKeys?: string[];
        requiredSignatures?: number;
        requiredRefundSignatures?: number;
    };
};

// @public
export type SwapPayload = {
    inputs: Proof[];
    outputs: SerializedBlindedMessage[];
};

// @public
export type SwapResponse = {
    signatures: SerializedBlindedSignature[];
} & ApiError;

// @public
export type SwapTransaction = {
    payload: SwapPayload;
    outputData: OutputData[];
    keepVector: boolean[];
    sortedIndices: number[];
};

// @public
export type Token = {
    mint: string;
    proofs: Proof[];
    memo?: string;
    unit?: string;
};

// @public @deprecated (undocumented)
export type TokenV2 = {
    proofs: Proof[];
    mints: Array<{
        url: string;
        ids: string[];
    }>;
};

// @public
export type TokenV4Template = {
    t: V4InnerToken[];
    d: string;
    m: string;
    u: string;
};

// @public (undocumented)
export type V4DLEQTemplate = {
    e: Uint8Array;
    s: Uint8Array;
    r: Uint8Array;
};

// @public
export type V4InnerToken = {
    i: Uint8Array;
    p: V4ProofTemplate[];
};

// @public
export type V4ProofTemplate = {
    a: number;
    s: string;
    c: Uint8Array;
    d?: V4DLEQTemplate;
    w?: string;
};

// @public
export class Wallet {
    constructor(mint: Mint | string, options?: {
        unit?: string;
        keys?: MintKeys[] | MintKeys | MintActiveKeys;
        keysets?: MintKeyset[] | MintAllKeysets;
        mintInfo?: GetInfoResponse;
        bip39seed?: Uint8Array;
        denominationTarget?: number;
        keepFactory?: OutputDataFactory;
        logger?: Logger;
    });
    batchRestore(gapLimit?: number, batchSize?: number, counter?: number, keysetId?: string): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    checkMeltQuote(quote: string | MeltQuoteResponse): Promise<MeltQuoteResponse | PartialMeltQuoteResponse>;
    checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse>;
    checkMintQuote(quote: string | MintQuoteResponse): Promise<MintQuoteResponse | PartialMintQuoteResponse>;
    checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse>;
    checkProofsStates(proofs: Proof[]): Promise<ProofState[]>;
    createLockedMintQuote(amount: number, pubkey: string, description?: string): Promise<LockedMintQuoteResponse>;
    createMeltQuote(invoice: string): Promise<MeltQuoteResponse>;
    createMeltQuoteBolt12(offer: string, amountMsat?: number): Promise<Bolt12MeltQuoteResponse>;
    createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse>;
    createMintQuoteBolt12(pubkey: string, options?: {
        amount?: number;
        description?: string;
    }): Promise<Bolt12MintQuoteResponse>;
    createMultiPathMeltQuote(invoice: string, millisatPartialAmount: number): Promise<MeltQuoteResponse>;
    getFeesForKeyset(nInputs: number, keysetId: string): number;
    getFeesForProofs(proofs: Proof[]): number;
    getMintInfo(): MintInfo;
    readonly keyChain: KeyChain;
    loadMint(forceRefresh?: boolean): Promise<void>;
    meltProofs(meltQuote: MeltQuoteResponse, proofsToSend: Proof[], outputType?: OutputType, config?: MeltProofsConfig): Promise<MeltProofsResponse>;
    meltProofsAsDefault(meltQuote: MeltQuoteResponse, proofsToSend: Proof[], config?: MeltProofsConfig): Promise<MeltProofsResponse>;
    meltProofsAsDeterministic(meltQuote: MeltQuoteResponse, proofsToSend: Proof[], counter: number, config?: MeltProofsConfig): Promise<MeltProofsResponse>;
    meltProofsBolt12(meltQuote: Bolt12MeltQuoteResponse, proofsToSend: Proof[], outputType?: OutputType, config?: MeltProofsConfig): Promise<{
        quote: Bolt12MeltQuoteResponse;
        change: Proof[];
    }>;
    readonly mint: Mint;
    mintProofs(amount: number, quote: string | MintQuoteResponse, outputType?: OutputType, config?: MintProofsConfig): Promise<Proof[]>;
    mintProofsAsDefault(amount: number, quote: string | MintQuoteResponse, config?: MintProofsConfig): Promise<Proof[]>;
    mintProofsAsDeterministic(amount: number, quote: string | MintQuoteResponse, counter: number, splitAmounts?: number[], proofsWeHave?: Proof[], config?: MintProofsConfig): Promise<Proof[]>;
    mintProofsAsP2PK(amount: number, quote: string | MintQuoteResponse, p2pkOptions: P2PKOptions, splitAmounts?: number[], proofsWeHave?: Proof[], config?: MintProofsConfig): Promise<Proof[]>;
    mintProofsBolt12(amount: number, quote: Bolt12MintQuoteResponse, privkey: string, outputType?: OutputType, config?: {
        keysetId?: string;
    }): Promise<Proof[]>;
    onMeltQuotePaid(quoteId: string, callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMeltQuoteUpdates(quoteIds: string[], callback: (payload: MeltQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMintQuotePaid(quoteId: string, callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onMintQuoteUpdates(quoteIds: string[], callback: (payload: MintQuoteResponse) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    onProofStateUpdates(proofs: Proof[], callback: (payload: ProofState & {
        proof: Proof;
    }) => void, errorCallback: (e: Error) => void): Promise<SubscriptionCanceller>;
    receive(token: Token | string, outputType?: OutputType, config?: {
        privkey?: string;
        requireDleq?: boolean;
        keysetId?: string;
    }): Promise<Proof[]>;
    receiveAsCustom(token: Token | string, data: OutputData[], config?: ReceiveConfig): Promise<Proof[]>;
    receiveAsDefault(token: Token | string, config?: ReceiveConfig): Promise<Proof[]>;
    receiveAsDeterministic(token: Token | string, counter: number, splitAmounts?: number[], proofsWeHave?: Proof[], config?: ReceiveConfig): Promise<Proof[]>;
    receiveAsFactory(token: Token | string, factory: OutputDataFactory, splitAmounts?: number[], proofsWeHave?: Proof[], config?: ReceiveConfig): Promise<Proof[]>;
    receiveAsP2PK(token: Token | string, options: P2PKOptions, splitAmounts?: number[], proofsWeHave?: Proof[], config?: ReceiveConfig): Promise<Proof[]>;
    restore(start: number, count: number, options?: RestoreOptions): Promise<{
        proofs: Proof[];
        lastCounterWithSignature?: number;
    }>;
    selectProofsToSend(proofs: Proof[], amountToSend: number, includeFees?: boolean, exactMatch?: boolean): SendResponse;
    send(amount: number, proofs: Proof[], outputConfig?: OutputConfig, config?: {
        privkey?: string;
        keysetId?: string;
        includeFees?: boolean;
    }): Promise<SendResponse>;
    sendAsDefault(amount: number, proofs: Proof[], config?: SendConfig): Promise<SendResponse>;
    sendAsDeterministic(amount: number, proofs: Proof[], counter: number, config?: SendConfig): Promise<SendResponse>;
    sendAsP2PK(amount: number, proofs: Proof[], p2pkOptions: P2PKOptions, counter?: number, config?: SendConfig): Promise<SendResponse>;
    sendOffline(amount: number, proofs: Proof[], config?: {
        privkey?: string;
        requireDleq?: boolean;
        includeFees?: boolean;
        exactMatch?: boolean;
    }): SendResponse;
    sendWithP2PKChange(amount: number, proofs: Proof[], p2pkOptions: P2PKOptions, config?: SendConfig): Promise<SendResponse>;
    readonly swap: (amount: number, proofs: Proof[], outputConfig?: OutputConfig, config?: {
        privkey?: string;
        keysetId?: string;
        includeFees?: boolean;
    }) => Promise<SendResponse>;
    get unit(): string;
}

// @public
export type WebSocketSupport = {
    method: string;
    unit: string;
    commands: string[];
};

// Warnings were encountered during analysis:
//
// lib/types/CashuWallet.d.ts:41:9 - (ae-forgotten-export) The symbol "OutputDataFactory" needs to be exported by the entry point index.d.ts
// lib/types/model/types/index.d.ts:150:5 - (ae-forgotten-export) The symbol "OutputDataLike" needs to be exported by the entry point index.d.ts
// lib/types/model/types/index.d.ts:190:5 - (ae-forgotten-export) The symbol "RpcSubKinds" needs to be exported by the entry point index.d.ts
// lib/types/model/types/index.d.ts:218:5 - (ae-forgotten-export) The symbol "JsonRpcParams" needs to be exported by the entry point index.d.ts
// lib/types/model/types/wallet/tokens.d.ts:103:5 - (ae-forgotten-export) The symbol "TokenEntry" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
