"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const et=require("buffer"),Xt=require("./crypto/client/NUT12.cjs.js"),Y=require("./crypto/common.cjs.js"),U=require("@noble/curves/abstract/utils"),Yt=require("@noble/hashes/sha256"),Pt=require("./crypto/client/NUT11.cjs.js"),Zt=require("./crypto/client/NUT20.cjs.js"),V=require("./crypto/client.cjs.js"),W=require("@noble/hashes/utils"),It=require("./crypto/client/NUT09.cjs.js"),te=require("./crypto/client/NUTXX.cjs.js");function ee(n){return et.Buffer.from(n).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function Dt(n){return et.Buffer.from(n,"base64")}function Kt(n){const t=JSON.stringify(n);return re(et.Buffer.from(t).toString("base64"))}function se(n){const t=et.Buffer.from(ne(n),"base64").toString();return JSON.parse(t)}function ne(n){return n.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function re(n){return n.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function oe(n){return typeof n=="number"||typeof n=="string"}function bt(n){const t=[];return _t(n,t),new Uint8Array(t)}function _t(n,t){if(n===null)t.push(246);else if(n===void 0)t.push(247);else if(typeof n=="boolean")t.push(n?245:244);else if(typeof n=="number")Bt(n,t);else if(typeof n=="string")Rt(n,t);else if(Array.isArray(n))ae(n,t);else if(n instanceof Uint8Array)ie(n,t);else if(typeof n=="object"&&n!==null&&!Array.isArray(n))ce(n,t);else throw new Error("Unsupported type")}function Bt(n,t){if(n<24)t.push(n);else if(n<256)t.push(24,n);else if(n<65536)t.push(25,n>>8,n&255);else if(n<4294967296)t.push(26,n>>24,n>>16&255,n>>8&255,n&255);else throw new Error("Unsupported integer size")}function ie(n,t){const e=n.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>24&255,e>>16&255,e>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let s=0;s<n.length;s++)t.push(n[s])}function Rt(n,t){const e=new TextEncoder().encode(n),s=e.length;if(s<24)t.push(96+s);else if(s<256)t.push(120,s);else if(s<65536)t.push(121,s>>8&255,s&255);else if(s<4294967296)t.push(122,s>>24&255,s>>16&255,s>>8&255,s&255);else throw new Error("String too long to encode");for(let r=0;r<e.length;r++)t.push(e[r])}function ae(n,t){const e=n.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>8,e&255);else throw new Error("Unsupported array length");for(const s of n)_t(s,t)}function ce(n,t){const e=Object.keys(n);Bt(e.length,t),t[t.length-1]|=160;for(const s of e)Rt(s,t),_t(n[s],t)}function Et(n){const t=new DataView(n.buffer,n.byteOffset,n.byteLength);return ct(t,0).value}function ct(n,t){if(t>=n.byteLength)throw new Error("Unexpected end of data");const e=n.getUint8(t++),s=e>>5,r=e&31;switch(s){case 0:return ue(n,t,r);case 1:return he(n,t,r);case 2:return le(n,t,r);case 3:return de(n,t,r);case 4:return fe(n,t,r);case 5:return pe(n,t,r);case 7:return ge(n,t,r);default:throw new Error(`Unsupported major type: ${s}`)}}function st(n,t,e){if(e<24)return{value:e,offset:t};if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const s=n.getUint16(t,!1);return t+=2,{value:s,offset:t}}if(e===26){const s=n.getUint32(t,!1);return t+=4,{value:s,offset:t}}if(e===27){const s=n.getUint32(t,!1),r=n.getUint32(t+4,!1);return t+=8,{value:s*2**32+r,offset:t}}throw new Error(`Unsupported length: ${e}`)}function ue(n,t,e){const{value:s,offset:r}=st(n,t,e);return{value:s,offset:r}}function he(n,t,e){const{value:s,offset:r}=st(n,t,e);return{value:-1-s,offset:r}}function le(n,t,e){const{value:s,offset:r}=st(n,t,e);if(r+s>n.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(n.buffer,n.byteOffset+r,s),offset:r+s}}function de(n,t,e){const{value:s,offset:r}=st(n,t,e);if(r+s>n.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(n.buffer,n.byteOffset+r,s);return{value:new TextDecoder().decode(o),offset:r+s}}function fe(n,t,e){const{value:s,offset:r}=st(n,t,e),o=[];let i=r;for(let a=0;a<s;a++){const c=ct(n,i);o.push(c.value),i=c.offset}return{value:o,offset:i}}function pe(n,t,e){const{value:s,offset:r}=st(n,t,e),o={};let i=r;for(let a=0;a<s;a++){const c=ct(n,i);if(!oe(c.value))throw new Error("Invalid key type");const u=ct(n,c.offset);o[c.value]=u.value,i=u.offset}return{value:o,offset:i}}function ye(n){const t=(n&31744)>>10,e=n&1023,s=n&32768?-1:1;return t===0?s*2**-14*(e/1024):t===31?e?NaN:s*(1/0):s*2**(t-15)*(1+e/1024)}function ge(n,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const s=ye(n.getUint16(t,!1));return t+=2,{value:s,offset:t}}if(e===26){const s=n.getFloat32(t,!1);return t+=4,{value:s,offset:t}}if(e===27){const s=n.getFloat64(t,!1);return t+=8,{value:s,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}class dt{constructor(t,e,s,r,o,i,a=!1,c){this.transport=t,this.id=e,this.amount=s,this.unit=r,this.mints=o,this.description=i,this.singleUse=a,this.nut10=c}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),t}toEncodedRequest(){const t=this.toRawRequest(),e=bt(t);return"creqA"+et.Buffer.from(e).toString("base64")}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(r=>({type:r.t,target:r.a,tags:r.g})):void 0,s=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new dt(e,t.i,t.a,t.u,t.m,t.d,t.s,s)}static fromEncodedRequest(t){if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const s=t.slice(5),r=Dt(s),o=Et(r);return this.fromRawRequest(o)}}const me="A",we="cashu";function B(n,t,e,s){if(e){const o=xt(e);if(o>n)throw new Error(`Split is greater than total amount: ${o} > ${n}`);if(e.some(i=>!Nt(i,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");n=n-xt(e)}else e=[];return Ut(t,"desc").forEach(o=>{const i=Math.floor(n/o);for(let a=0;a<i;++a)e?.push(o);n%=o}),e.sort((o,i)=>o-i)}function Tt(n,t,e,s){const r=[],o=n.map(u=>u.amount);Ut(e,"asc").forEach(u=>{const h=o.filter(d=>d===u).length,l=Math.max(s-h,0);for(let d=0;d<l&&!(r.reduce((y,b)=>y+b,0)+u>t);++d)r.push(u)});const a=t-r.reduce((u,h)=>u+h,0);return a&&B(a,e).forEach(h=>{r.push(h)}),r.sort((u,h)=>u-h)}function Ut(n,t="desc"){return t=="desc"?Object.keys(n).map(e=>parseInt(e)).sort((e,s)=>s-e):Object.keys(n).map(e=>parseInt(e)).sort((e,s)=>e-s)}function Nt(n,t){return n in t}function ke(n){return Ot(U.bytesToHex(n))}function Ot(n){return BigInt(`0x${n}`)}function be(n){return n.toString(16).padStart(64,"0")}function Mt(n){return/^[a-f0-9]*$/i.test(n)}function Ft(n){return Array.isArray(n)?n.some(t=>!Mt(t.id)):Mt(n.id)}function _e(n,t){t&&(n.proofs=ut(n.proofs));const e={token:[{mint:n.mint,proofs:n.proofs}]};return n.unit&&(e.unit=n.unit),n.memo&&(e.memo=n.memo),we+me+Kt(e)}function Ee(n,t){if(Ft(n.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return _e(n,t?.removeDleq)}return Lt(n,t?.removeDleq)}function Lt(n,t){if(t&&(n.proofs=ut(n.proofs)),n.proofs.forEach(c=>{if(c.dleq&&c.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Ft(n.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");const s=Ct(n),r=bt(s),o="cashu",i="B",a=ee(r);return o+i+a}function Ct(n){const t={},e=n.mint;for(let r=0;r<n.proofs.length;r++){const o=n.proofs[r];t[o.id]?t[o.id].push(o):t[o.id]=[o]}const s={m:e,u:n.unit||"sat",t:Object.keys(t).map(r=>({i:U.hexToBytes(r),p:t[r].map(o=>({a:o.amount,s:o.secret,c:U.hexToBytes(o.C),...o.dleq&&{d:{e:U.hexToBytes(o.dleq.e),s:U.hexToBytes(o.dleq.s),r:U.hexToBytes(o.dleq.r??"00")}},...o.witness&&{w:JSON.stringify(o.witness)}}))}))};return n.memo&&(s.d=n.memo),s}function Wt(n){const t=[];n.t.forEach(s=>s.p.forEach(r=>{t.push({secret:r.s,C:U.bytesToHex(r.c),amount:r.a,id:U.bytesToHex(s.i),...r.d&&{dleq:{r:U.bytesToHex(r.d.r),s:U.bytesToHex(r.d.s),e:U.bytesToHex(r.d.e)}},...r.w&&{witness:r.w}})}));const e={mint:n.m,proofs:t,unit:n.u||"sat"};return n.d&&(e.memo=n.d),e}function Qt(n){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{n.startsWith(e)&&(n=n.slice(e.length))}),Ae(n)}function Ae(n){const t=n.slice(0,1),e=n.slice(1);if(t==="A"){const s=se(e);if(s.token.length>1)throw new Error("Multi entry token are not supported");const r=s.token[0],o={mint:r.mint,proofs:r.proofs,unit:s.unit||"sat"};return s.memo&&(o.memo=s.memo),o}else if(t==="B"){const s=Dt(e),r=Et(s);return Wt(r)}throw new Error("Token version is not supported")}function qt(n){return jt(n.keys)===n.id}function jt(n){const t=Object.entries(n).sort((r,o)=>+r[0]-+o[0]).map(([,r])=>U.hexToBytes(r)).reduce((r,o)=>Se(r,o),new Uint8Array),e=Yt.sha256(t);return"00"+et.Buffer.from(e).toString("hex").slice(0,14)}function Se(n,t){const e=new Uint8Array(n.length+t.length);return e.set(n),e.set(t,n.length),e}function Q(n){return typeof n=="object"}function q(...n){return n.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function Ht(n){return n.replace(/\/$/,"")}function z(n){return n.reduce((t,e)=>t+e.amount,0)}function Pe(n){return dt.fromEncodedRequest(n)}class Ie{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class Te{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new Ie(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function ut(n){return n.map(t=>{const e={...t};return delete e.dleq,e})}function At(n,t){if(n.dleq==null)return!1;const e={e:U.hexToBytes(n.dleq.e),s:U.hexToBytes(n.dleq.s),r:Ot(n.dleq.r??"00")};if(!Nt(n.amount,t.keys))throw new Error(`undefined key for amount ${n.amount}`);const s=t.keys[n.amount];return!!Xt.verifyDLEQProof_reblind(new TextEncoder().encode(n.secret),e,Y.pointFromHex(n.C),Y.pointFromHex(s))}function Me(...n){const t=n.reduce((r,o)=>r+o.length,0),e=new Uint8Array(t);let s=0;for(let r=0;r<n.length;r++)e.set(n[r],s),s=s+n[r].length;return e}function qe(n){const t=new TextEncoder,e=Ct(n),s=bt(e),r=t.encode("craw"),o=t.encode("B");return Me(r,o,s)}function xe(n){const t=new TextDecoder,e=t.decode(n.slice(0,4)),s=t.decode(new Uint8Array([n[4]]));if(e!=="craw"||s!=="B")throw new Error("not a valid binary token");const r=n.slice(5),o=Et(r);return Wt(o)}function xt(n){return n.reduce((t,e)=>t+e,0)}let ht;typeof WebSocket<"u"&&(ht=WebSocket);function ve(n){ht=n}function De(){if(ht===void 0)throw new Error("WebSocket implementation not initialized");return ht}const S={FATAL:"FATAL",ERROR:"ERROR",WARN:"WARN",INFO:"INFO",DEBUG:"DEBUG",TRACE:"TRACE"},j={fatal(){},error(){},warn(){},info(){},debug(){},trace(){},log(){}},nt=class nt{constructor(t=S.INFO){this.minLevel=t}logToConsole(t,e,s){if(nt.SEVERITY[t]>nt.SEVERITY[this.minLevel])return;const r=`[${t}] `;let o=e;const i=new Set;if(s){const a=Object.fromEntries(Object.entries(s).map(([h,l])=>[h,l instanceof Error?{message:l.message,stack:l.stack}:l]));o=e.replace(/\{(\w+)\}/g,(h,l)=>{if(l in a&&a[l]!==void 0){i.add(l);const d=a[l];return typeof d=="string"?d:typeof d=="number"||typeof d=="boolean"?d.toString():d==null?"":JSON.stringify(d)}return h});const c=Object.fromEntries(Object.entries(a).filter(([h])=>!i.has(h))),u=this.getConsoleMethod(t);Object.keys(c).length>0?u(r+o,c):u(r+o)}else this.getConsoleMethod(t)(r+o)}getConsoleMethod(t){switch(t){case S.FATAL:case S.ERROR:return console.error;case S.WARN:return console.warn;case S.INFO:return console.info;case S.DEBUG:return console.debug;case S.TRACE:return console.trace;default:return console.log}}fatal(t,e){this.logToConsole(S.FATAL,t,e)}error(t,e){this.logToConsole(S.ERROR,t,e)}warn(t,e){this.logToConsole(S.WARN,t,e)}info(t,e){this.logToConsole(S.INFO,t,e)}debug(t,e){this.logToConsole(S.DEBUG,t,e)}trace(t,e){this.logToConsole(S.TRACE,t,e)}log(t,e,s){this.logToConsole(t,e,s)}};nt.SEVERITY={[S.FATAL]:0,[S.ERROR]:1,[S.WARN]:2,[S.INFO]:3,[S.DEBUG]:4,[S.TRACE]:5};let wt=nt;function Ke(){const n=Date.now();return{elapsed:()=>Date.now()-n}}class J{constructor(){this.connectionMap=new Map}static getInstance(){return J.instance||(J.instance=new J),J.instance}getConnection(t,e){if(this.connectionMap.has(t))return this.connectionMap.get(t);const s=new Be(t,e);return this.connectionMap.set(t,s),s}}class Be{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=De(),this.url=new URL(t),this.messageQueue=new Te,this._logger=e??j}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,e)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(s){e(s instanceof Error?s:new Error(String(s)));return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{e(new Error("Failed to open WebSocket"))},this.ws.onmessage=s=>{this.messageQueue.enqueue(s.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=s=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(r=>r(s))}})),this.connectionPromise}sendRequest(t,e){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const s=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:s});this.ws?.send(r)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}addRpcListener(t,e,s){this.rpcListeners[s]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(s=>s!==e)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMessage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let e;try{if(e=JSON.parse(t),"result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const s=e.params?.subId;if(!s)return;if(this.subListeners[s]?.length>0){const r=e;this.subListeners[s].forEach(o=>o(r.params?.payload))}}}catch(s){this._logger.error("Error doing handleNextMessage",{e:s});return}}createSubscription(t,e,s){if(this.ws?.readyState!==1)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,e)},s,this.rpcId),this.sendRequest("subscribe",{...t,subId:r}),this.rpcId++,r}cancelSubscription(t,e,s){this.removeListener(t,e),this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},s||(r=>this._logger.error("Unsubscribe failed",{e:r})),this.rpcId),this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}}const Re={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"},Z={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},lt={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"};var $t=(n=>(n.POST="post",n.NOSTR="nostr",n))($t||{});class tt extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,tt.prototype)}}class ft extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,ft.prototype)}}class pt extends tt{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,pt.prototype)}}let zt={},at=j;function Ue(n){zt=n}function Ne(n){at=n}async function Oe({endpoint:n,requestBody:t,headers:e,...s}){const r=t?JSON.stringify(t):void 0,o={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...e};let i;try{at.debug?.("HTTP request",{method:s.method??"GET",url:n,bodyLength:r?.length??0,headers:o}),i=await fetch(n,{body:r,headers:o,...s})}catch(u){throw new ft(u instanceof Error?u.message:"Network request failed")}const a=i.headers.get("content-type")??"",c=await i.text().catch(()=>{});if(!i.ok){let u="HTTP request failed",h;if(a.includes("application/json")&&c)try{h=JSON.parse(c)}catch{}else if(c&&c.trim().startsWith("{"))try{h=JSON.parse(c)}catch{}let l=h&&typeof h=="object"?h:void 0;throw i.status===400&&l&&"code"in l&&typeof l.code=="number"&&"detail"in l&&typeof l.detail=="string"?new pt(l.code,l.detail):(l?"error"in l&&typeof l.error=="string"?u=l.error:"detail"in l&&typeof l.detail=="string"&&(u=l.detail):c&&c.trim().length>0?u=c.trim():u="bad response",at.error?.("HTTP error response",{method:s.method??"GET",url:n,status:i.status,statusText:i.statusText,contentType:a,bodySnippet:c?c.slice(0,2e3):void 0}),new tt(u,i.status))}try{return c&&c.length>0?JSON.parse(c):null}catch(u){throw at.error?.("Failed to parse HTTP response",{err:u instanceof Error?u.message:String(u),url:n,status:i.status,contentType:a,bodySnippet:c?c.slice(0,2e3):void 0}),new tt("bad response",i.status)}}async function K(n){return await Oe({...n,...zt})}function gt(n,t){return n.state||(t.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof n.paid=="boolean"&&(n.state=n.paid?Z.PAID:Z.UNPAID)),n}function vt(n,t){return n.state||(t.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof n.paid=="boolean"&&(n.state=n.paid?lt.PAID:lt.UNPAID)),n}function Fe(n,t){return Array.isArray(n?.contact)&&n?.contact.length>0&&(n.contact=n.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),n}class kt{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(e=>({method:e.method,regex:new RegExp(e.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const e=this._protectedEnpoints.apiReturn.some(s=>s.regex.test(t));return this._protectedEnpoints.cache[t]=e,e}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}}class D{constructor(t,e,s,r){this._mintUrl=t,this._customRequest=e,this._checkNut22=!1,this._mintUrl=Ht(t),this._customRequest=e,s&&(this._checkNut22=!0,this._authTokenGetter=s),this._logger=r?.logger??j,Ne(this._logger)}get mintUrl(){return this._mintUrl}static async getInfo(t,e,s){const r=s??j,i=await(e||K)({endpoint:q(t,"/v1/info")});return Fe(i,r)}async getInfo(){return D.getInfo(this._mintUrl,this._customRequest,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await D.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new kt(t),this._mintInfo}static async swap(t,e,s,r){const o=s||K,i=r?{"Blind-auth":r}:{},a=await o({endpoint:q(t,"/v1/swap"),method:"POST",requestBody:e,headers:i});if(!Q(a)||!Array.isArray(a?.signatures))throw new Error(a.detail??"bad response");return a}async swap(t){const e=await this.handleBlindAuth("/v1/swap");return D.swap(this._mintUrl,t,this._customRequest,e)}static async createMintQuote(t,e,s,r,o){const i=o??j,a=s||K,c=r?{"Blind-auth":r}:{},u=await a({endpoint:q(t,"/v1/mint/quote/bolt11"),method:"POST",requestBody:e,headers:c});return vt(u,i)}async createMintQuote(t){const e=await this.handleBlindAuth("/v1/mint/quote/bolt11");return D.createMintQuote(this._mintUrl,t,this._customRequest,e)}static async checkMintQuote(t,e,s,r,o){const i=o??j,a=s||K,c=r?{"Blind-auth":r}:{},u=await a({endpoint:q(t,"/v1/mint/quote/bolt11",e),method:"GET",headers:c});return vt(u,i)}async checkMintQuote(t){const e=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);return D.checkMintQuote(this._mintUrl,t,this._customRequest,e)}static async mint(t,e,s,r){const o=s||K,i=r?{"Blind-auth":r}:{},a=await o({endpoint:q(t,"/v1/mint/bolt11"),method:"POST",requestBody:e,headers:i});if(!Q(a)||!Array.isArray(a?.signatures))throw new Error("bad response");return a}async mint(t){const e=await this.handleBlindAuth("/v1/mint/bolt11");return D.mint(this._mintUrl,t,this._customRequest,e)}static async createMeltQuote(t,e,s,r,o){const i=o??j,a=s||K,c=r?{"Blind-auth":r}:{},u=await a({endpoint:q(t,"/v1/melt/quote/bolt11"),method:"POST",requestBody:e,headers:c}),h=gt(u,i);if(!Q(h)||typeof h?.amount!="number"||typeof h?.fee_reserve!="number"||typeof h?.quote!="string")throw new Error("bad response");return h}async createMeltQuote(t){const e=await this.handleBlindAuth("/v1/melt/quote/bolt11");return D.createMeltQuote(this._mintUrl,t,this._customRequest,e)}static async checkMeltQuote(t,e,s,r,o){const i=o??j,a=s||K,c=r?{"Blind-auth":r}:{},u=await a({endpoint:q(t,"/v1/melt/quote/bolt11",e),method:"GET",headers:c}),h=gt(u,i);if(!Q(h)||typeof h?.amount!="number"||typeof h?.fee_reserve!="number"||typeof h?.quote!="string"||typeof h?.state!="string"||!Object.values(Z).includes(h.state))throw new Error("bad response");return h}async checkMeltQuote(t){const e=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);return D.checkMeltQuote(this._mintUrl,t,this._customRequest,e)}static async melt(t,e,s,r,o){const i=o??j,a=s||K,c=r?{"Blind-auth":r}:{},u=await a({endpoint:q(t,"/v1/melt/bolt11"),method:"POST",requestBody:e,headers:c}),h=gt(u,i);if(!Q(h)||typeof h?.state!="string"||!Object.values(Z).includes(h.state))throw new Error("bad response");return h}async melt(t){const e=await this.handleBlindAuth("/v1/melt/bolt11");return D.melt(this._mintUrl,t,this._customRequest,e)}static async check(t,e,s){const o=await(s||K)({endpoint:q(t,"/v1/checkstate"),method:"POST",requestBody:e});if(!Q(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(t,e,s){e&&(e=e.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(s||K)({endpoint:e?q(t,"/v1/keys",e):q(t,"/v1/keys")});if(!Q(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await D.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||K)({endpoint:q(t,"/v1/keysets")})}async getKeySets(){return D.getKeySets(this._mintUrl,this._customRequest)}async check(t){return D.check(this._mintUrl,t,this._customRequest)}static async restore(t,e,s){const o=await(s||K)({endpoint:q(t,"/v1/restore"),method:"POST",requestBody:e});if(!Q(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(t){return D.restore(this._mintUrl,t,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),e="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e),this.ws=J.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(s){throw this._logger.error("Failed to connect to WebSocket...",{e:s}),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(t){if(!this._checkNut22)return;if((await this.getLazyMintInfo()).requiresBlindAuthToken(t)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}}class it{constructor(t,e,s){this.amount=t,this.B_=e,this.id=s}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function mt(n){return typeof n=="function"}class C{constructor(t,e,s){this.secret=s,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let s;t.dleq&&(s={s:W.hexToBytes(t.dleq.s),e:W.hexToBytes(t.dleq.e),r:this.blindingFactor});const r={id:t.id,amount:t.amount,C_:Y.pointFromHex(t.C_)},o=Y.pointFromHex(e.keys[t.amount]),i=V.constructProofFromPromise(r,this.blindingFactor,this.secret,o);return{...V.serializeProof(i),...s&&{dleq:{s:W.bytesToHex(s.s),e:W.bytesToHex(s.e),r:be(s.r??BigInt(0))}}}}static createP2PKData(t,e,s,r){return B(e,s.keys,r).map(i=>this.createSingleP2PKData(t,i,s.id))}static createCairoData(t,e,s,r){return B(e,s.keys,r).map(i=>this.createSingleCairoData(t,i,s.id))}static createSingleP2PKData(t,e,s){const r=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],o=Math.max(1,Math.min(t.requiredSignatures||1,r.length)),i=Math.max(1,Math.min(t.requiredRefundSignatures||1,t.refundKeys?t.refundKeys.length:1)),a=["P2PK",{nonce:W.bytesToHex(W.randomBytes(32)),data:r[0],tags:[]}];t.locktime&&a[1].tags.push(["locktime",String(t.locktime)]),r.length>1&&(a[1].tags.push(["pubkeys",...r.slice(1)]),o>1&&a[1].tags.push(["n_sigs",String(o)])),t.refundKeys&&(a[1].tags.push(["refund",...t.refundKeys]),i>1&&a[1].tags.push(["n_sigs_refund",String(i)]));const c=JSON.stringify(a),u=new TextEncoder().encode(c),{r:h,B_:l}=V.blindMessage(u);return new C(new it(e,l,s).getSerializedBlindedMessage(),h,u)}static createSingleCairoData(t,e,s){const r=["Cairo",{nonce:W.bytesToHex(W.randomBytes(32)),data:t.programHash,tags:[["program_output",t.outputHash]]}],o=JSON.stringify(r),i=new TextEncoder().encode(o),{r:a,B_:c}=V.blindMessage(i);return new C(new it(e,c,s).getSerializedBlindedMessage(),a,i)}static createRandomData(t,e,s){return B(t,e.keys,s).map(o=>this.createSingleRandomData(o,e.id))}static createSingleRandomData(t,e){const s=W.bytesToHex(W.randomBytes(32)),r=new TextEncoder().encode(s),{r:o,B_:i}=V.blindMessage(r);return new C(new it(t,i,e).getSerializedBlindedMessage(),o,r)}static createDeterministicData(t,e,s,r,o){return B(t,r.keys,o).map((a,c)=>this.createSingleDeterministicData(a,e,s+c,r.id))}static createSingleDeterministicData(t,e,s,r){const o=It.deriveSecret(e,r,s),i=W.bytesToHex(o),a=new TextEncoder().encode(i),c=ke(It.deriveBlindingFactor(e,r,s)),{r:u,B_:h}=V.blindMessage(a,c);return new C(new it(t,h,r).getSerializedBlindedMessage(),u,a)}}const Le=3,Ce="sat";class We{constructor(t,e){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=Ce,this._mintInfo=void 0,this._denominationTarget=Le,this.mint=t,this._logger=e?.logger??j;let s=[];if(e?.keys&&!Array.isArray(e.keys)?s=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(s=e?.keys),s&&s.forEach(r=>this._keys.set(r.id,r)),e?.unit&&(this._unit=e?.unit),e?.keysets&&(this._keysets=e.keysets),e?.mintInfo&&(this._mintInfo=new kt(e.mintInfo)),e?.denominationTarget&&(this._denominationTarget=e.denominationTarget),e?.bip39seed){if(e.bip39seed instanceof Uint8Array){this._seed=e.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}e?.keepFactory&&(this._keepFactory=e.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new kt(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await this.getMintInfo(),await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active&&r.unit===this._unit);e=e.filter(r=>r.id.startsWith("00"));const s=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!s)throw new Error("No active keyset found");return s}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(s=>s.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return t.keysets.forEach(e=>{if(!qt(e))throw new Error(`Couldn't verify keyset ID ${e.id}`)}),this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(s=>s.id===t)&&(await this.getKeySets(),!this._keysets.find(s=>s.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const s=await this.mint.getKeys(t);if(!qt(s.keysets[0]))throw new Error(`Couldn't verify keyset ID ${s.keysets[0].id}`);this._keys.set(t,s.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,e){const{requireDleq:s,keysetId:r,outputAmounts:o,counter:i,pubkey:a,privkey:c,outputData:u,p2pk:h,cairoReceive:l}=e||{};typeof t=="string"&&(t=Qt(t));const d=await this.getKeys(r);if(s&&t.proofs.some(N=>!At(N,d)))throw new Error("Token contains proofs with invalid DLEQ");const y=z(t.proofs)-this.getFeesForProofs(t.proofs);let b;u?b={send:u}:this._keepFactory&&(b={send:this._keepFactory});const w=await this.createSwapPayload(y,t.proofs,d,o,i,a,c,b,h,l),{signatures:k}=await this.mint.swap(w.payload),E=w.outputData.map((N,v)=>N.toProof(k[v],d)),x=[];return w.sortedIndices.forEach((N,v)=>{x[N]=E[v]}),x}async send(t,e,s){const{offline:r,includeFees:o,includeDleq:i,keysetId:a,outputAmounts:c,pubkey:u,privkey:h,outputData:l}=s||{};if(i&&(e=e.filter(w=>w.dleq!=null)),z(e)<t)throw new Error("Not enough funds available to send");const{keep:d,send:y}=this.selectProofsToSend(e,t,s?.includeFees),b=o?this.getFeesForProofs(y):0;if(!r&&(z(y)!=t+b||c||u||h||a||l)){const w=await this.swap(t,e,s),{keep:k,send:E}=w,x=w.serialized;return{keep:k,send:E,serialized:x}}if(z(y)<t+b)throw new Error("Not enough funds available to send");return{keep:d,send:y}}selectProofsToSend(t,e,s=!1){const h=Ke();let l=null,d=1/0,y=0,b=0;const w=(p,f)=>p-(s?Math.ceil(f/1e3):0),k=p=>{const f=[...p];for(let m=f.length-1;m>0;m--){const g=Math.floor(Math.random()*(m+1));[f[m],f[g]]=[f[g],f[m]]}return f},E=(p,f,m)=>{let g=0,O=p.length-1,R=null;for(;g<=O;){const A=Math.floor((g+O)/2),I=p[A].exFee;(m?I<=f:I>=f)?(R=A,m?g=A+1:O=A-1):m?O=A-1:g=A+1}return m?R:g<p.length?g:null},x=(p,f)=>{const m=f.exFee;let g=0,O=p.length;for(;g<O;){const R=Math.floor((g+O)/2);p[R].exFee<m?g=R+1:O=R}p.splice(g,0,f)},N=(p,f)=>w(p,f)<e?1/0:p+f/1e3-e;let v=0,_=0;const T=t.map(p=>{const f=this.getProofFeePPK(p),m=s?p.amount-f/1e3:p.amount,g={proof:p,exFee:m,ppkfee:f};return(!s||m>0)&&(v+=p.amount,_+=f),g});let P=s?T.filter(p=>p.exFee>0):T;if(P.sort((p,f)=>p.exFee-f.exFee),P.length>0){let p;{const f=E(P,e,!1);if(f!==null){const m=P[f].exFee,g=E(P,m,!0);if(g===null)throw new Error("Unexpected null rightIndex in binary search");p=g+1}else p=P.length}for(let f=p;f<P.length;f++)v-=P[f].proof.amount,_-=P[f].ppkfee;P=P.slice(0,p)}const rt=w(v,_);if(e<=0||e>rt)return{keep:t,send:[]};const H=Math.min(Math.ceil(e*(1+0/100)),e+0,rt);for(let p=0;p<60;p++){const f=[];let m=0,g=0;for(const M of k(P)){const F=m+M.proof.amount,L=g+M.ppkfee,$=w(F,L);if(f.push(M),m=F,g=L,$>=e)break}const O=new Set(f),R=P.filter(M=>!O.has(M)),A=k(Array.from({length:f.length},(M,F)=>F)).slice(0,5e3);for(const M of A){const F=w(m,g);if(F===e||F>=e&&F<=H)break;const L=f[M],$=m-L.proof.amount,G=g-L.ppkfee,Jt=w($,G),St=e-Jt,yt=E(R,St,!1);if(yt!==null){const ot=R[yt];(St>=0||ot.exFee<=L.exFee)&&(f[M]=ot,m=$+ot.proof.amount,g=G+ot.ppkfee,R.splice(yt,1),x(R,L))}}const I=N(m,g);if(I<d){this._logger.debug("selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}",{trial:p,amount:m,delta:I}),l=[...f].sort((F,L)=>L.exFee-F.exFee),d=I,y=m,b=g;const M=[...l];for(;M.length>1&&d>0;){const F=M.pop(),L=m-F.proof.amount,$=g-F.ppkfee,G=N(L,$);if(G==1/0)break;G<d&&(l=[...M],d=G,y=L,b=$,m=L,g=$)}}if(l&&d<1/0){const M=w(y,b);if(M===e||M>=e&&M<=H)break}if(h.elapsed()>1e3){this._logger.warn("Proof selection took too long. Returning best selection so far.");break}}if(l&&d<1/0){const p=l.map(g=>g.proof),f=new Set(p),m=t.filter(g=>!f.has(g));return this._logger.info("Proof selection took {time}ms",{time:h.elapsed()}),{keep:m,send:p}}return{keep:t,send:[]}}getFeesForProofs(t){const e=t.reduce((s,r)=>s+this.getProofFeePPK(r),0);return Math.ceil(e/1e3)}getProofFeePPK(t){const e=this._keysets.find(s=>s.id===t.id);if(!e)throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);return e?.input_fee_ppk||0}getFeesForKeyset(t,e){return Math.floor(Math.max((t*(this._keysets.find(r=>r.id===e)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,e,s){let{outputAmounts:r}=s||{};const{includeFees:o,keysetId:i,counter:a,pubkey:c,privkey:u,proofsWeHave:h,outputData:l,p2pk:d,cairoSend:y,cairoReceive:b}=s||{},w=await this.getKeys(i);let k=t;const E=z(e);let x=r?.sendAmounts||B(k,w.keys);if(o){let A=this.getFeesForKeyset(x.length,w.id),I=B(A,w.keys);for(;this.getFeesForKeyset(x.concat(I).length,w.id)>A;)A++,I=B(A,w.keys);x=x.concat(I),k+=A}const{keep:N,send:v}=this.selectProofsToSend(e,k,!0),_=z(v)-this.getFeesForProofs(v)-k;if(_<0)throw new Error("Not enough balance to send");let T;if(!r?.keepAmounts&&!h)T=B(_,w.keys);else if(!r?.keepAmounts&&h)T=Tt(h,_,w.keys,this._denominationTarget);else if(r){if(r.keepAmounts?.reduce((A,I)=>A+I,0)!=_)throw new Error("Keep amounts do not match amount to keep");T=r.keepAmounts}if(k+this.getFeesForProofs(v)>E)throw this._logger.error(`Not enough funds available (${E}) for swap amountToSend: ${k} + fee: ${this.getFeesForProofs(v)} | length: ${v.length}`),new Error("Not enough funds available for swap");r={keepAmounts:T,sendAmounts:x};const P=l?.keep||this._keepFactory,rt=l?.send,H=await this.createSwapPayload(k,v,w,r,a,c,u,{keep:P,send:rt},d,b,y),{signatures:p}=await this.mint.swap(H.payload),f=H.outputData.map((A,I)=>A.toProof(p[I],w)),m=[],g=[],O=Array(H.keepVector.length),R=Array(f.length);return H.sortedIndices.forEach((A,I)=>{O[A]=H.keepVector[I],R[A]=f[I]}),R.forEach((A,I)=>{O[I]?m.push(A):g.push(A)}),{keep:[...m,...N],send:g}}async batchRestore(t=300,e=100,s=0,r){const o=Math.ceil(t/e),i=[];let a,c=0;for(;c<o;){const u=await this.restore(s,e,{keysetId:r});u.proofs.length>0?(c=0,i.push(...u.proofs),a=u.lastCounterWithSignature):c++,s+=e}return{proofs:i,lastCounterWithSignature:a}}async restore(t,e,s){const{keysetId:r}=s||{},o=await this.getKeys(r);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const i=Array(e).fill(1),a=C.createDeterministicData(i.length,this._seed,t,o,i),{outputs:c,signatures:u}=await this.mint.restore({outputs:a.map(y=>y.blindedMessage)}),h={};c.forEach((y,b)=>h[y.B_]=u[b]);const l=[];let d;for(let y=0;y<a.length;y++){const b=h[a[y].blindedMessage.B_];b&&(d=t+y,a[y].blindedMessage.amount=b.amount,l.push(a[y].toProof(b,o)))}return{proofs:l,lastCounterWithSignature:d}}async createMintQuote(t,e){const s={unit:this._unit,amount:t,description:e},r=await this.mint.createMintQuote(s);return{...r,amount:r.amount||t,unit:r.unit||this.unit}}async createLockedMintQuote(t,e,s){const{supported:r}=(await this.getMintInfo()).isSupported(20);if(!r)throw new Error("Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:s,pubkey:e},i=await this.mint.createMintQuote(o);if(typeof i.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const a=i.pubkey;return{...i,pubkey:a,amount:i.amount||t,unit:i.unit||this.unit}}}async checkMintQuote(t){const e=typeof t=="string"?t:t.quote,s=await this.mint.checkMintQuote(e);return typeof t=="string"?s:{...s,amount:s.amount||t.amount,unit:s.unit||t.unit}}async mintProofs(t,e,s){let{outputAmounts:r}=s||{};const{counter:o,pubkey:i,p2pk:a,keysetId:c,proofsWeHave:u,outputData:h,privateKey:l}=s||{},d=await this.getKeys(c);!r&&u&&(r={keepAmounts:Tt(u,t,d.keys,this._denominationTarget),sendAmounts:[]});let y=[];if(h)if(mt(h)){const k=B(t,d.keys,r?.keepAmounts);for(let E=0;E<k.length;E++)y.push(h(k[E],d))}else y=h;else if(this._keepFactory){const k=B(t,d.keys,r?.keepAmounts);for(let E=0;E<k.length;E++)y.push(this._keepFactory(k[E],d))}else y=this.createOutputData(t,d,o,i,r?.keepAmounts,a);let b;if(typeof e!="string"){if(!l)throw new Error("Can not sign locked quote without private key");const k=y.map(x=>x.blindedMessage),E=Zt.signMintQuote(l,e.quote,k);b={outputs:k,quote:e.quote,signature:E}}else b={outputs:y.map(k=>k.blindedMessage),quote:e};const{signatures:w}=await this.mint.mint(b);return y.map((k,E)=>k.toProof(w[E],d))}async createMeltQuote(t){const e={unit:this._unit,request:t},s=await this.mint.createMeltQuote(e);return{...s,unit:s.unit||this.unit,request:s.request||t}}async createMultiPathMeltQuote(t,e){const{supported:s,params:r}=(await this.lazyGetMintInfo()).isSupported(15);if(!s)throw new Error("Mint does not support NUT-15");if(!r?.some(u=>u.method==="bolt11"&&u.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const i={mpp:{amount:e}},a={unit:this._unit,request:t,options:i};return{...await this.mint.createMeltQuote(a),request:t,unit:this._unit}}async checkMeltQuote(t){const e=typeof t=="string"?t:t.quote,s=await this.mint.checkMeltQuote(e);return typeof t=="string"?s:{...s,request:t.request,unit:t.unit}}async meltProofs(t,e,s){const{keysetId:r,counter:o,privkey:i}=s||{},a=await this.getKeys(r),c=this.createBlankOutputs(z(e)-t.amount,a,o,this._keepFactory);i!=null&&(e=Pt.signP2PKProofs(e,i)),e=ut(e),e=e.map(l=>{const d=l.witness&&typeof l.witness!="string"?JSON.stringify(l.witness):l.witness;return{...l,witness:d}});const u={quote:t.quote,inputs:e,outputs:c.map(l=>l.blindedMessage)},h=await this.mint.melt(u);return{quote:{...h,unit:t.unit,request:t.request},change:h.change?.map((l,d)=>c[d].toProof(l,a))??[]}}async createSwapPayload(t,e,s,r,o,i,a,c,u,h,l){const d=e.reduce((_,T)=>_+T.amount,0);r&&r.sendAmounts&&!r.keepAmounts&&(r.keepAmounts=B(d-t-this.getFeesForProofs(e),s.keys));const y=d-t-this.getFeesForProofs(e);let b=[],w=[];if(c?.keep)if(mt(c.keep)){const _=c.keep;B(y,s.keys).forEach(P=>{b.push(_(P,s))})}else b=c.keep;else b=this.createOutputData(y,s,o,void 0,r?.keepAmounts,void 0,void 0,this._keepFactory);if(c?.send)if(mt(c.send)){const _=c.send;B(t,s.keys).forEach(P=>{w.push(_(P,s))})}else w=c.send;else w=this.createOutputData(t,s,o?o+b.length:void 0,i,r?.sendAmounts,u,l);a?e=Pt.signP2PKProofs(e,a):h&&(e=await te.cairoProveProofs(e,h.executable,h.programInput)),e=ut(e),e=e.map(_=>{const T=_.witness&&typeof _.witness!="string"?JSON.stringify(_.witness):_.witness;return{..._,witness:T}});const k=[...b,...w],E=k.map((_,T)=>T).sort((_,T)=>k[_].blindedMessage.amount-k[T].blindedMessage.amount),x=[...Array.from({length:b.length},()=>!0),...Array.from({length:w.length},()=>!1)],N=E.map(_=>k[_]),v=E.map(_=>x[_]);return{payload:{inputs:e,outputs:N.map(_=>_.blindedMessage)},outputData:N,keepVector:v,sortedIndices:E}}async checkProofsStates(t){const e=new TextEncoder,s=t.map(i=>Y.hashToCurve(e.encode(i.secret)).toHex(!0)),r=100,o=[];for(let i=0;i<s.length;i+=r){const a=s.slice(i,i+r),{states:c}=await this.mint.check({Ys:a}),u={};c.forEach(h=>{u[h.Y]=h});for(let h=0;h<a.length;h++){const l=u[a[h]];if(!l)throw new Error("Could not find state for proof with Y: "+a[h]);o.push(l)}}return o}async onMintQuoteUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},e,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onMeltQuotePaid(t,e,s){return this.onMeltQuoteUpdates([t],r=>{r.state===Z.PAID&&e(r)},s)}async onMintQuotePaid(t,e,s){return this.onMintQuoteUpdates([t],r=>{r.state===lt.PAID&&e(r)},s)}async onMeltQuoteUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},e,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onProofStateUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=new TextEncoder,o={};for(let c=0;c<t.length;c++){const u=Y.hashToCurve(r.encode(t[c].secret)).toHex(!0);o[u]=t[c]}const i=Object.keys(o),a=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:i},c=>{e({...c,proof:o[c.Y]})},s);return()=>{this.mint.webSocketConnection?.cancelSubscription(a,e)}}createOutputData(t,e,s,r,o,i,a,c){let u;if(r)u=C.createP2PKData({pubkey:r},t,e,o);else if(s||s===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");u=C.createDeterministicData(t,this._seed,s,e,o)}else i?u=C.createP2PKData(i,t,e,o):a?u=C.createCairoData(a,t,e,o):c?u=B(t,e.keys).map(l=>c(l,e)):u=C.createRandomData(t,e,o);return u}createBlankOutputs(t,e,s,r){let o=Math.ceil(Math.log2(t))||1;o<0&&(o=0);const i=o?Array(o).fill(1):[];return this.createOutputData(i.length,e,s,void 0,i,void 0,void 0,r)}}class X{constructor(t,e){this._mintUrl=t,this._customRequest=e,this._mintUrl=Ht(t),this._customRequest=e}get mintUrl(){return this._mintUrl}static async mint(t,e,s,r){const o=r||K,i={"Clear-auth":`${s}`},a=await o({endpoint:q(t,"/v1/auth/blind/mint"),method:"POST",requestBody:e,headers:i});if(!Q(a)||!Array.isArray(a?.signatures))throw new Error("bad response");return a}async mint(t,e){return X.mint(this._mintUrl,t,e,this._customRequest)}static async getKeys(t,e,s){const o=await(s||K)({endpoint:e?q(t,"/v1/auth/blind/keys",e):q(t,"/v1/auth/blind/keys")});if(!Q(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await X.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||K)({endpoint:q(t,"/v1/auth/blind/keysets")})}async getKeySets(){return X.getKeySets(this._mintUrl,this._customRequest)}}class Gt{constructor(t,e){this._keys=new Map,this._keysets=[],this._unit="auth",this.mint=t;let s=[];e?.keys&&!Array.isArray(e.keys)?s=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(s=e?.keys),s&&s.forEach(r=>this._keys.set(r.id,r)),e?.keysets&&(this._keysets=e.keysets)}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}async loadMint(){await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active);e=e.filter(r=>r.id.startsWith("00"));const s=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!s)throw new Error("No active keyset found");return s}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(s=>s.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(s=>s.id===t)&&(await this.getKeySets(),!this._keysets.find(s=>s.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const s=await this.mint.getKeys(t);this._keys.set(t,s.keysets[0])}return this.keysetId=t,this._keys.get(t)}async mintProofs(t,e,s){const r=await this.getKeys(s?.keysetId),o=C.createRandomData(t,r),i={outputs:o.map(u=>u.blindedMessage)},{signatures:a}=await this.mint.mint(i,e),c=o.map((u,h)=>u.toProof(a[h],r));if(c.some(u=>!At(u,r)))throw new Error("Mint returned auth proofs with invalid DLEQ");return c}}function Vt(n){const t={id:n.id,secret:n.secret,C:n.C},e=Kt(t);return"auth"+"A"+e}async function Qe(n,t,e){const s=new X(t);return(await new Gt(s).mintProofs(n,e)).map(i=>Vt(i))}exports.CashuAuthMint=X;exports.CashuAuthWallet=Gt;exports.CashuMint=D;exports.CashuWallet=We;exports.CheckStateEnum=Re;exports.ConsoleLogger=wt;exports.HttpResponseError=tt;exports.LogLevel=S;exports.MeltQuoteState=Z;exports.MintOperationError=pt;exports.MintQuoteState=lt;exports.NetworkError=ft;exports.OutputData=C;exports.PaymentRequest=dt;exports.PaymentRequestTransportType=$t;exports.decodePaymentRequest=Pe;exports.deriveKeysetId=jt;exports.getBlindedAuthToken=Qe;exports.getDecodedToken=Qt;exports.getDecodedTokenBinary=xe;exports.getEncodedAuthToken=Vt;exports.getEncodedToken=Ee;exports.getEncodedTokenBinary=qe;exports.getEncodedTokenV4=Lt;exports.hasValidDleq=At;exports.injectWebSocketImpl=ve;exports.setGlobalRequestOptions=Ue;
//# sourceMappingURL=cashu-ts.cjs.js.map
