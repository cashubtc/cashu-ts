{"version":3,"file":"cashu-ts.es.js","sources":["../src/base64.ts","../src/cbor.ts","../src/model/PaymentRequest.ts","../src/utils/Constants.ts","../src/utils.ts","../src/ws.ts","../src/logger.ts","../src/WSConnection.ts","../src/model/types/mint/responses.ts","../src/model/types/wallet/paymentRequests.ts","../src/model/Errors.ts","../src/request.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/CashuMint.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/CashuWallet.ts","../src/auth/CashuAuthMint.ts","../src/auth/CashuAuthWallet.ts","../src/auth/index.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Buffer.from(uint8array).toString('base64');\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Buffer.from(bytes)\n\t\t.toString('base64')\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Buffer.from(base64String, 'base64');\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Buffer.from(jsonString).toString('base64'));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Buffer.from(base64urlToBase64(base64String), 'base64').toString();\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n};\n","type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\ttype RawPaymentRequest,\n\ttype RawTransport,\n\ttype NUT10Option,\n\ttype PaymentRequestTransport,\n\ttype PaymentRequestTransportType,\n} from './types';\nimport { Buffer } from 'buffer';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Buffer.from(data).toString('base64');\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * Per protocol definition since tokenV3 tokens have a prefix and a version number.\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { Buffer } from 'buffer';\nimport { verifyDLEQProof_reblind } from './crypto/client/NUT12';\nimport { type DLEQ, pointFromHex } from './crypto/common/index';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from './model/PaymentRequest';\nimport {\n\ttype DeprecatedToken,\n\ttype Keys,\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedDLEQ,\n\ttype Token,\n\ttype TokenV4Template,\n\ttype V4DLEQTemplate,\n\ttype V4InnerToken,\n\ttype V4ProofTemplate,\n} from './model/types/index';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants';\n\n/**\n * Splits the amount into denominations of the provided @param keyset.\n *\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts.\n * @throws Error if @param split amount is greater than @param value amount.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\t\tif (totalSplitAmount > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalSplitAmount} > ${value}`);\n\t\t}\n\t\tif (split.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\t\tvalue = value - sumArray(split);\n\t} else {\n\t\tsplit = [];\n\t}\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split?.push(amt);\n\t\tvalue %= amt;\n\t});\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\tconst sortedAmountsWeWant = amountsWeWant.sort((a, b) => a - b);\n\treturn sortedAmountsWeWant;\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nfunction isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(token: string) {\n\t// remove prefixes\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn handleTokens(token);\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\tconst decodedToken = tokenFromTemplate(tokenData);\n\t\treturn decodedToken;\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Recomputes the ID for the provided keyset and verifies it matches the ID provided by the Mint.\n *\n * @param keys The keyset to be verified.\n * @returns True if the verification succeeded, false otherwise.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\treturn deriveKeysetId(keys.keys) === keys.id;\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @returns\n */\nexport function deriveKeysetId(keys: Keys) {\n\tconst pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\tif (\n\t\t!verifyDLEQProof_reblind(\n\t\t\tnew TextEncoder().encode(proof.secret),\n\t\t\tdleq,\n\t\t\tpointFromHex(proof.C),\n\t\t\tpointFromHex(key),\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport const LogLevel = {\n\tFATAL: 'FATAL',\n\tERROR: 'ERROR',\n\tWARN: 'WARN',\n\tINFO: 'INFO',\n\tDEBUG: 'DEBUG',\n\tTRACE: 'TRACE',\n} as const;\n\n/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\nexport interface Logger {\n\tfatal(message: string, context?: Record<string, unknown>): void;\n\terror(message: string, context?: Record<string, unknown>): void;\n\twarn(message: string, context?: Record<string, unknown>): void;\n\tinfo(message: string, context?: Record<string, unknown>): void;\n\tdebug(message: string, context?: Record<string, unknown>): void;\n\ttrace(message: string, context?: Record<string, unknown>): void;\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void;\n}\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\tfatal() {},\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\tpublic static readonly SEVERITY: Record<LogLevel, number> = {\n\t\t[LogLevel.FATAL]: 0,\n\t\t[LogLevel.ERROR]: 1,\n\t\t[LogLevel.WARN]: 2,\n\t\t[LogLevel.INFO]: 3,\n\t\t[LogLevel.DEBUG]: 4,\n\t\t[LogLevel.TRACE]: 5,\n\t};\n\tconstructor(minLevel: LogLevel = LogLevel.INFO) {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate logToConsole(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tif (ConsoleLogger.SEVERITY[level] > ConsoleLogger.SEVERITY[this.minLevel]) return;\n\t\tconst levelPrefix = `[${level}] `;\n\t\tlet interpolatedMessage = message;\n\t\tconst usedKeys = new Set<string>();\n\t\tif (context) {\n\t\t\tconst processedContext = Object.fromEntries(\n\t\t\t\tObject.entries(context).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue instanceof Error ? { message: value.message, stack: value.stack } : value,\n\t\t\t\t]),\n\t\t\t);\n\t\t\tinterpolatedMessage = message.replace(/\\{(\\w+)\\}/g, (match: string, key: string) => {\n\t\t\t\tif (key in processedContext && processedContext[key] !== undefined) {\n\t\t\t\t\tusedKeys.add(key);\n\t\t\t\t\tconst value: unknown = processedContext[key];\n\t\t\t\t\tif (typeof value === 'string') return value;\n\t\t\t\t\tif (typeof value === 'number' || typeof value === 'boolean') return value.toString();\n\t\t\t\t\tif (value == null) return '';\n\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tconst filteredContext = Object.fromEntries(\n\t\t\t\tObject.entries(processedContext).filter(([key]) => !usedKeys.has(key)),\n\t\t\t);\n\t\t\tconst consoleMethod = this.getConsoleMethod(level);\n\t\t\tif (Object.keys(filteredContext).length > 0) {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage, filteredContext);\n\t\t\t} else {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.getConsoleMethod(level)(levelPrefix + interpolatedMessage);\n\t\t}\n\t}\n\t// Note: NOT static as test suite needs to spy on the output\n\tprivate getConsoleMethod(level: LogLevel): (message: string, ...args: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase LogLevel.FATAL:\n\t\t\tcase LogLevel.ERROR:\n\t\t\t\treturn console.error;\n\t\t\tcase LogLevel.WARN:\n\t\t\t\treturn console.warn;\n\t\t\tcase LogLevel.INFO:\n\t\t\t\treturn console.info;\n\t\t\tcase LogLevel.DEBUG:\n\t\t\t\treturn console.debug;\n\t\t\tcase LogLevel.TRACE:\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\t// We could throw, but that's a bit aggressive for a logging class\n\t\t\t\t// so just use a regular console.log()\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\t// Interface methods\n\tfatal(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.FATAL, message, context);\n\t}\n\terror(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.ERROR, message, context);\n\t}\n\twarn(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.WARN, message, context);\n\t}\n\tinfo(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.INFO, message, context);\n\t}\n\tdebug(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.DEBUG, message, context);\n\t}\n\ttrace(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.TRACE, message, context);\n\t}\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { MessageQueue } from './utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from './model/types';\nimport { type OnOpenError, type OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint.\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * Keyset id for indicating which public key was used to sign the blinded message.\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi.\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature.\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof.\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","import { type Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\nimport { type Logger, NULL_LOGGER } from './logger';\nimport { type ApiError } from './model/types/mint/responses';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\trequestLogger.debug?.('HTTP request', {\n\t\t\tmethod: options.method ?? 'GET',\n\t\t\turl: endpoint,\n\t\t\tbodyLength: body?.length ?? 0,\n\t\t\theaders,\n\t\t});\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tconst contentType = response.headers.get('content-type') ?? '';\n\tconst rawText = await response.text().catch(() => undefined);\n\n\tif (!response.ok) {\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tlet parsed: unknown;\n\t\tif (contentType.includes('application/json') && rawText) {\n\t\t\ttry {\n\t\t\t\tparsed = JSON.parse(rawText);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t} else if (rawText && rawText.trim().startsWith('{')) {\n\t\t\ttry {\n\t\t\t\tparsed = JSON.parse(rawText);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\tlet errorData: ApiError | undefined =\n\t\t\tparsed && typeof parsed === 'object' ? (parsed as ApiError) : undefined;\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\terrorData &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof (errorData as any).code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof (errorData as any).detail === 'string'\n\t\t) {\n\t\t\t// Specific mint operation error\n\t\t\tthrow new MintOperationError((errorData as any).code, (errorData as any).detail);\n\t\t}\n\n\t\tif (errorData) {\n\t\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\t\terrorMessage = errorData.error;\n\t\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\t\terrorMessage = errorData.detail;\n\t\t\t}\n\t\t} else if (rawText && rawText.trim().length > 0) {\n\t\t\terrorMessage = rawText.trim();\n\t\t} else {\n\t\t\terrorMessage = 'bad response';\n\t\t}\n\t\trequestLogger.error?.('HTTP error response', {\n\t\t\tmethod: options.method ?? 'GET',\n\t\t\turl: endpoint,\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\tcontentType,\n\t\t\tbodySnippet: rawText ? rawText.slice(0, 2000) : undefined,\n\t\t});\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\tif (rawText && rawText.length > 0) {\n\t\t\treturn JSON.parse(rawText);\n\t\t}\n\t\t// empty 204/205\n\t\treturn null;\n\t} catch (err) {\n\t\trequestLogger.error?.('Failed to parse HTTP response', {\n\t\t\terr: err instanceof Error ? err.message : String(err),\n\t\t\turl: endpoint,\n\t\t\tstatus: response.status,\n\t\t\tcontentType,\n\t\t\tbodySnippet: rawText ? rawText.slice(0, 2000) : undefined,\n\t\t});\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { PartialMeltQuoteResponse } from '../model/types/index';\nimport { MeltQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../model/types/index';\nimport { MintQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\tprivate readonly _protectedEnpoints?: {\n\t\tcache: {\n\t\t\t[url: string]: boolean;\n\t\t};\n\t\tapiReturn: Array<{ method: 'GET' | 'POST'; regex: RegExp; cachedValue?: boolean }>;\n\t};\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t\tif (info.nuts[22]) {\n\t\t\tthis._protectedEnpoints = {\n\t\t\t\tcache: {},\n\t\t\t\tapiReturn: info.nuts[22].protected_endpoints.map((o) => ({\n\t\t\t\t\tmethod: o.method,\n\t\t\t\t\tregex: new RegExp(o.path),\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(path: string) {\n\t\tif (!this._protectedEnpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof this._protectedEnpoints.cache[path] === 'boolean') {\n\t\t\treturn this._protectedEnpoints.cache[path];\n\t\t}\n\t\tconst isProtectedEndpoint = this._protectedEnpoints.apiReturn.some((e) => e.regex.test(path));\n\t\tthis._protectedEnpoints.cache[path] = isProtectedEndpoint;\n\t\treturn isProtectedEndpoint;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n}\n","import { ConnectionManager, type WSConnection } from './WSConnection';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n} from './model/types/index';\nimport { MeltQuoteState } from './model/types/index';\nimport request, { setRequestLogger } from './request';\nimport { isObj, joinUrls, sanitizeUrl } from './utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from './legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from './legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER } from './logger';\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented\n * by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authTokenGetter?: () => Promise<string>;\n\tprivate _checkNut22 = false;\n\tprivate _logger: Logger;\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t * @param [authTokenGetter] A function that is called by the CashuMint instance to obtain a NUT-22\n\t *   BlindedAuthToken (e.g. from a database or localstorage)\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t\tauthTokenGetter?: () => Promise<string>,\n\t\toptions?: {\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t\tif (authTokenGetter) {\n\t\t\tthis._checkNut22 = true;\n\t\t\tthis._authTokenGetter = authTokenGetter;\n\t\t}\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\t//TODO: v3 - refactor CashuMint to take two or less args.\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t\tlogger?: Logger,\n\t): Promise<GetInfoResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest, this._logger);\n\t}\n\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param mintUrl\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest\n\t * @returns Signed outputs.\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/swap');\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt11');\n\t\treturn CashuMint.createMintQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @param customRequest\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt11');\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt11');\n\t\treturn CashuMint.createMeltQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens\n\t * matching its amount + fees.\n\t *\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt11');\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: SerializedBlindedMessage[];\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\tasync handleBlindAuth(path: string) {\n\t\tif (!this._checkNut22) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (info.requiresBlindAuthToken(path)) {\n\t\t\tif (!this._authTokenGetter) {\n\t\t\t\tthrow new Error('Can not call a protected endpoint without authProofGetter');\n\t\t\t}\n\t\t\treturn this._authTokenGetter();\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport { CashuMint };\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type ProjPointType } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: ProjPointType<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: ProjPointType<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { blindMessage, constructProofFromPromise, serializeProof } from '../crypto/client/index';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { type DLEQ, pointFromHex } from '../crypto/common/index';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '../crypto/client/NUT09';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createCairoData(\n\t\tcairoSend: { programHash: string; outputHash: string },\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleCairoData(cairoSend, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\t// Standardize pubkey (backwards compat), clamp n_sigs between 1 and total pubkeys\n\t\t// clamp n_sigs_refund between 1 and total refundKeys, and create secret\n\t\tconst pubkeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst n_sigs: number = Math.max(1, Math.min(p2pk.requiredSignatures || 1, pubkeys.length));\n\t\tconst n_sigs_refund: number = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures || 1, p2pk.refundKeys ? p2pk.refundKeys.length : 1),\n\t\t);\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: pubkeys[0], // Primary key\n\t\t\t\ttags: [],\n\t\t\t},\n\t\t];\n\t\tif (p2pk.locktime) {\n\t\t\tnewSecret[1].tags.push(['locktime', String(p2pk.locktime)]); // NUT-10 string\n\t\t}\n\t\tif (pubkeys.length > 1) {\n\t\t\tnewSecret[1].tags.push(['pubkeys', ...pubkeys.slice(1)]); // Additional keys\n\t\t\tif (n_sigs > 1) {\n\t\t\t\t// 1 is the default, so we can save space if not multisig\n\t\t\t\tnewSecret[1].tags.push(['n_sigs', String(n_sigs)]); // NUT-10 string\n\t\t\t}\n\t\t}\n\t\tif (p2pk.refundKeys) {\n\t\t\tnewSecret[1].tags.push(['refund', ...p2pk.refundKeys]);\n\t\t\tif (n_sigs_refund > 1) {\n\t\t\t\t// 1 is the default, so we can save space if not multisig\n\t\t\t\tnewSecret[1].tags.push(['n_sigs_refund', String(n_sigs_refund)]); // NUT-10 string\n\t\t\t}\n\t\t}\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createSingleCairoData(\n\t\tcairoSend: { programHash: string; outputHash: string },\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'Cairo',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: cairoSend.programHash,\n\t\t\t\ttags: [['program_output', cairoSend.outputHash]],\n\t\t\t},\n\t\t];\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n}\n","import { signP2PKProofs } from './crypto/client/NUT11';\nimport { hashToCurve } from './crypto/common/index';\nimport { type CashuMint } from './CashuMint';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER, measureTime } from './logger';\nimport type {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSwapOptions,\n\tMeltPayload,\n\tMeltProofsResponse,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tMintKeys,\n\tMintKeyset,\n\tMintPayload,\n\tMintQuotePayload,\n\tProof,\n\tSendResponse,\n\tToken,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n} from './model/types/index';\nimport { MintQuoteState, MeltQuoteState } from './model/types/index';\nimport { type SubscriptionCanceller } from './model/types/wallet/websocket';\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs,\n\tverifyKeysetId,\n} from './utils';\nimport { signMintQuote } from './crypto/client/NUT20';\nimport {\n\tOutputData,\n\ttype OutputDataFactory,\n\ttype OutputDataLike,\n\tisOutputDataFactory,\n} from './model/OutputData';\nimport { cairoProveProofs } from './crypto/client/NUTXX';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet. This class should act as the entry point for this library.\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\tprivate _logger: Logger;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls.\n\t * @param options.unit Optionally set unit (default is 'sat')\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo Mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget Target number proofs per denomination (default: see @constant\n\t *   DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that\n\t *   produce proofs to be kept (change, etc.). This can lead to poor performance, in which case\n\t *   the seed should be directly provided.\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getMintInfo();\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active && k.unit === this._unit);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tkeysets.keysets.forEach((k) => {\n\t\t\tif (!verifyKeysetId(k)) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${k.id}`);\n\t\t\t}\n\t\t});\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tif (!verifyKeysetId(keys.keysets[0])) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${keys.keysets[0].id}`);\n\t\t\t}\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the\n\t * first token in the token array)\n\t *\n\t * @param {string | Token} token - Cashu token, either as string or decoded.\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing.\n\t * @returns New token with newly created proofs, token entries that had errors.\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Proof[]> {\n\t\tconst {\n\t\t\trequireDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t} = options || {};\n\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: OutputDataLike[] | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = await this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation.\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Proof[], options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t} = options || {};\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees,\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\tconst sendRes = await this.swap(amount, proofs, options);\n\t\t\tconst { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(proofs: Proof[], amountToSend: number, includeFees = false): SendResponse {\n\t\t// Init vars\n\t\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\t\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\t\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\t\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\t\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\t\tconst exactMatch = false; // Allows close match (> amountToSend + fee)\n\t\tconst timer = measureTime(); // start the clock\n\t\tlet bestSubset: ProofWithFee[] | null = null;\n\t\tlet bestDelta = Infinity;\n\t\tlet bestAmount = 0;\n\t\tlet bestFeePPK = 0;\n\n\t\t/**\n\t\t * Helper Functions.\n\t\t */\n\t\tinterface ProofWithFee {\n\t\t\tproof: Proof;\n\t\t\texFee: number;\n\t\t\tppkfee: number;\n\t\t}\n\t\t// Calculate net amount after fees\n\t\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t\t};\n\t\t// Shuffle array for randomization\n\t\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\t\tconst shuffled = [...array];\n\t\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t\t}\n\t\t\treturn shuffled;\n\t\t};\n\t\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\t\tconst binarySearchIndex = (\n\t\t\tarr: ProofWithFee[],\n\t\t\tvalue: number,\n\t\t\tlessOrEqual: boolean,\n\t\t): number | null => {\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length - 1,\n\t\t\t\tresult: number | null = null;\n\t\t\twhile (left <= right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tconst midValue = arr[mid].exFee;\n\t\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\t\tresult = mid;\n\t\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\t\telse right = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\t\telse left = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t\t};\n\t\t// Insert into array of ProofWithFee objects sorted by exFee\n\t\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\t\tconst value = obj.exFee;\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length;\n\t\t\twhile (left < right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\t\telse right = mid;\n\t\t\t}\n\t\t\tarr.splice(left, 0, obj);\n\t\t};\n\t\t// \"Delta\" is the excess over amountToSend including fees\n\t\t// plus a tiebreaker to favour lower PPK keysets\n\t\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\t\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\t\treturn amount + feePPK / 1000 - amountToSend;\n\t\t};\n\n\t\t/**\n\t\t * Pre-processing.\n\t\t */\n\t\tlet totalAmount = 0;\n\t\tlet totalFeePPK = 0;\n\t\tconst proofWithFees = proofs.map((p) => {\n\t\t\tconst ppkfee = this.getProofFeePPK(p);\n\t\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t\t// Sum all economical proofs (filtered below)\n\t\t\tif (!includeFees || exFee > 0) {\n\t\t\t\ttotalAmount += p.amount;\n\t\t\t\ttotalFeePPK += ppkfee;\n\t\t\t}\n\t\t\treturn obj;\n\t\t});\n\n\t\t// Filter uneconomical proofs (totals computed above)\n\t\tlet spendableProofs = includeFees\n\t\t\t? proofWithFees.filter((obj) => obj.exFee > 0)\n\t\t\t: proofWithFees;\n\n\t\t// Sort by exFee ascending\n\t\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t\t// Remove proofs too large to be useful and adjust totals\n\t\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\t\tif (spendableProofs.length > 0) {\n\t\t\tlet endIndex;\n\t\t\tif (exactMatch) {\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t\t} else {\n\t\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\t\tif (biggerIndex !== null) {\n\t\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\t\tif (rightIndex === null) {\n\t\t\t\t\t\tthrow new Error('Unexpected null rightIndex in binary search');\n\t\t\t\t\t}\n\t\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust totals for removed proofs\n\t\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t\t}\n\t\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t\t}\n\n\t\t// Validate using precomputed totals\n\t\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\t\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\t// Max acceptable amount for non-exact matches\n\t\tconst maxOverAmount = Math.min(\n\t\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\t\tamountToSend + MAX_OVRAMT,\n\t\t\ttotalNetSum,\n\t\t);\n\n\t\t/**\n\t\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees\n\t\t * are dynamic, based on number of proofs (PPK), so we perform all calculations based on net\n\t\t * amounts.\n\t\t */\n\t\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t\t// PHASE 1: Randomized Greedy Selection\n\t\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t\t// for exact match or the first amount over target otherwise\n\t\t\tconst S: ProofWithFee[] = [];\n\t\t\tlet amount = 0;\n\t\t\tlet feePPK = 0;\n\t\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\t\tS.push(obj);\n\t\t\t\tamount = newAmount;\n\t\t\t\tfeePPK = newFeePPK;\n\t\t\t\tif (netSum >= amountToSend) break;\n\t\t\t}\n\n\t\t\t// PHASE 2: Local Improvement\n\t\t\t// Examine all the amounts found in the first phase, and find the\n\t\t\t// amount not in the current solution (others), which would get us\n\t\t\t// closest to the amountToSend.\n\n\t\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t\t// Using array.includes() would be way slower: O(n*m)\n\t\t\tconst SSet = new Set(S);\n\t\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t\t// Generate a random order for accessing the trial subset ('S')\n\t\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t\t0,\n\t\t\t\tMAX_P2SWAP,\n\t\t\t);\n\t\t\tfor (const i of indices) {\n\t\t\t\t// Exact or acceptable close match solution found?\n\t\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\t\tif (\n\t\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\t\tconst objP = S[i];\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t\t// not replace larger unless it closes on the target\n\t\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\t\tif (qIndex !== null) {\n\t\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update best solution\n\t\t\tconst delta = calculateDelta(amount, feePPK);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tthis._logger.debug(\n\t\t\t\t\t'selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}',\n\t\t\t\t\t{ trial, amount, delta },\n\t\t\t\t);\n\t\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\t\tbestDelta = delta;\n\t\t\t\tbestAmount = amount;\n\t\t\t\tbestFeePPK = feePPK;\n\n\t\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t\t// optimal fee solutions more consistently\n\t\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if solution is acceptable\n\t\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\t\tif (\n\t\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Time limit reached?\n\t\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\t\tif (exactMatch) {\n\t\t\t\t\tthrow new Error('Proof selection took too long. Try again with a smaller proof set.');\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return Result\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t\tthis._logger.info('Proof selection took {time}ms', { time: timer.elapsed() });\n\t\t\treturn { keep, send: bestProofs };\n\t\t}\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof) {\n\t\tconst keyset = this._keysets.find((k) => k.id === proof.id);\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Could not get fee. No keyset found for keyset id: ${proof.id}`);\n\t\t}\n\t\treturn keyset?.input_fee_ppk || 0;\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0,\n\t\t\t),\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens if no amount is specified, the amount is implied by the\n\t * cumulative amount of all proofs if both amount and preference are set, but the preference\n\t * cannot fulfill the amount, then we use the default split.\n\t *\n\t * @param {SwapOptions} [options] - Optional parameters for configuring the swap operation.\n\t * @returns Promise of the change- and send-proofs.\n\t */\n\tasync swap(amount: number, proofs: Proof[], options?: SwapOptions): Promise<SendResponse> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst {\n\t\t\tincludeFees,\n\t\t\tkeysetId,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tproofsWeHave,\n\t\t\toutputData,\n\t\t\tp2pk,\n\t\t\tcairoSend,\n\t\t\tcairoReceive,\n\t\t} = options || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t}\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\t// input selection, needs fees because of the swap\n\t\tconst { keep: keepProofs, send: sendProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\ttrue, // inc. fees\n\t\t);\n\n\t\tconst amountToKeep = sumProofs(sendProofs) - this.getFeesForProofs(sendProofs) - amountToSend;\n\n\t\tif (amountToKeep < 0) {\n\t\t\tthrow new Error('Not enough balance to send');\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && !proofsWeHave) {\n\t\t\tkeepAmounts = splitAmount(amountToKeep, keyset.keys);\n\t\t} else if (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(sendProofs) > amountAvailable) {\n\t\t\tthis._logger.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tsendProofs,\n\t\t\t\t)} | length: ${sendProofs.length}`,\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts,\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = await this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tsendProofs,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t\tcairoSend,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Proof[] = [];\n\t\tconst splitProofsToSend: Proof[] = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...splitProofsToKeep, ...keepProofs],\n\t\t\tsend: splitProofsToSend,\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. keysetIds can be loaded with\n\t *   `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create blank amounts for unknown restore amounts\n\t\tconst amounts = Array(count).fill(1);\n\t\tconst outputData = OutputData.createDeterministicData(\n\t\t\tamounts.length,\n\t\t\tthis._seed,\n\t\t\tstart,\n\t\t\tkeys,\n\t\t\tamounts,\n\t\t);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote form the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this.unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = (await this.getMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (typeof res.pubkey !== 'string') {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t} else {\n\t\t\tconst pubkey = res.pubkey;\n\t\t\treturn { ...res, pubkey, amount: res.amount || amount, unit: res.unit || this.unit };\n\t\t}\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - Containing the quote ID and unlocking private key (when quote\n\t *   is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string },\n\t): Promise<Proof[]>;\n\tasync mintProofs(amount: number, quote: string, options?: MintProofOptions): Promise<Proof[]>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: [],\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: OutputData[] = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\t\tlet mintPayload: MintPayload;\n\t\tif (typeof quote !== 'string') {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\t\tconst mintQuoteSignature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t\tmintPayload = {\n\t\t\t\toutputs: blindedMessages,\n\t\t\t\tquote: quote.quote,\n\t\t\t\tsignature: mintQuoteSignature,\n\t\t\t};\n\t\t} else {\n\t\t\tmintPayload = {\n\t\t\t\toutputs: newBlindingData.map((d) => d.blindedMessage),\n\t\t\t\tquote: quote,\n\t\t\t};\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this.unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;\n\tasync checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory,\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t};\n\t}\n\n\t/**\n\t * Creates a split payload.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofsToSend Proofs to split*\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param privkey? Will create a signature on the @param proofsToSend secrets if set.\n\t * @param customOutputData? Optionally specify your own OutputData (blinded messages)\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @returns\n\t */\n\tprivate async createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Proof[],\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: OutputDataLike[] | OutputDataFactory;\n\t\t\tsend?: OutputDataLike[] | OutputDataFactory;\n\t\t},\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tcairoReceive?: {\n\t\t\texecutable: string;\n\t\t\tprogramInput: bigint[];\n\t\t},\n\t\tcairoSend?: {\n\t\t\tprogramHash: string;\n\t\t\toutputHash: string;\n\t\t},\n\t): Promise<SwapTransaction> {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys,\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: OutputDataLike[] = [];\n\t\tlet sendOutputData: OutputDataLike[] = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory,\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk,\n\t\t\t\tcairoSend,\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t} else if (cairoReceive) {\n\t\t\tproofsToSend = await cairoProveProofs(\n\t\t\t\tproofsToSend,\n\t\t\t\tcairoReceive.executable,\n\t\t\t\tcairoReceive.programInput,\n\t\t\t);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputData.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputData.length }, () => false),\n\t\t];\n\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage),\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Proof[]): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts.\n\t *\n\t * @param amount Array of amounts to create blinded messages for.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @param factory? Optionally specify a custom function that produces OutputData (blinded\n\t *   messages)\n\t * @returns Blinded messages, secrets, rs, and amounts.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: number[],\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tcairoSend?: {\n\t\t\tprogramHash: string;\n\t\t\toutputHash: string;\n\t\t},\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet outputData: OutputDataLike[];\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData({ pubkey }, amount, keyset, outputAmounts);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (cairoSend) {\n\t\t\toutputData = OutputData.createCairoData(cairoSend, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve See:\n\t * https://github.com/cashubtc/nuts/blob/main/08.md.\n\t *\n\t * @param amount Amount to cover with blank outputs.\n\t * @param keysetId Mint keysetId.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @returns Blinded messages, secrets, and rs.\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\tconst amounts = count ? Array(count).fill(1) : [];\n\t\treturn this.createOutputData(\n\t\t\tamounts.length,\n\t\t\tkeyset,\n\t\t\tcounter,\n\t\t\tundefined,\n\t\t\tamounts,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfactory,\n\t\t);\n\t}\n}\n\nexport { CashuWallet };\n","import {\n\ttype BlindAuthMintPayload,\n\ttype BlindAuthMintResponse,\n\ttype MintActiveKeys,\n\ttype MintAllKeysets,\n} from '../model/types';\nimport request from '../request';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\n\n/**\n * Class represents Cashu Auth Mint API. This class contains Lower level functions that are\n * implemented by CashuAuthWallet.\n */\nclass CashuAuthMint {\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: BlindAuthMintPayload,\n\t\tclearAuthToken: string,\n\t\tcustomRequest?: typeof request,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers = {\n\t\t\t'Clear-auth': `${clearAuthToken}`,\n\t\t};\n\t\tconst data = await requestInstance<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: BlindAuthMintPayload, clearAuthToken: string) {\n\t\treturn CashuAuthMint.mint(this._mintUrl, mintPayload, clearAuthToken, this._customRequest);\n\t}\n\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(mintUrl, '/v1/auth/blind/keys', keysetId)\n\t\t\t\t: joinUrls(mintUrl, '/v1/auth/blind/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuAuthMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuAuthMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n}\n\nexport { CashuAuthMint };\n","import { OutputData } from '../model/OutputData';\nimport {\n\ttype BlindAuthMintPayload,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype Proof,\n} from '../model/types';\nimport { hasValidDleq } from '../utils';\nimport { type CashuAuthMint } from './CashuAuthMint';\n\n/**\n * Class that represents a Cashu NUT-22 wallet.\n */\nclass CashuAuthWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _unit = 'auth';\n\n\tmint: CashuAuthMint;\n\n\t/**\n\t * @param mint NUT-22 auth mint instance.\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t */\n\tconstructor(\n\t\tmint: CashuAuthMint,\n\t\toptions?: {\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t}\n\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param clearAuthToken ClearAuthToken to mint.\n\t * @param options.keysetId? Optionally set keysetId for blank outputs for returned change.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tclearAuthToken: string,\n\t\toptions?: {\n\t\t\tkeysetId?: string;\n\t\t},\n\t): Promise<Proof[]> {\n\t\tconst keyset = await this.getKeys(options?.keysetId);\n\t\tconst outputData = OutputData.createRandomData(amount, keyset);\n\n\t\tconst mintPayload: BlindAuthMintPayload = {\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst { signatures } = await this.mint.mint(mintPayload, clearAuthToken);\n\t\tconst authProofs = outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tif (authProofs.some((p) => !hasValidDleq(p, keyset))) {\n\t\t\tthrow new Error('Mint returned auth proofs with invalid DLEQ');\n\t\t}\n\t\treturn authProofs;\n\t}\n}\n\nexport { CashuAuthWallet };\n","import { CashuAuthMint } from './CashuAuthMint';\nimport { CashuAuthWallet } from './CashuAuthWallet';\nimport { encodeJsonToBase64 } from '../base64';\nimport { type Proof } from '../model/types';\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nexport async function getBlindedAuthToken(amount: number, url: string, clearAuthToken: string) {\n\tconst authMint = new CashuAuthMint(url);\n\tconst authWallet = new CashuAuthWallet(authMint);\n\tconst authProofs = await authWallet.mintProofs(amount, clearAuthToken);\n\treturn authProofs.map((p) => getEncodedAuthToken(p));\n}\n\nexport { CashuAuthMint, CashuAuthWallet };\n"],"names":["encodeUint8toBase64Url","bytes","Buffer","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","i","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","nut10","rawRequest","t","type","rawPaymentRequest","transports","encodedRequest","encodedData","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","amt","hasCorrespondingKey","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","p","countWeHave","countWeWant","amountDiff","k","bytesToNumber","hexToNumber","bytesToHex","hex","numberToHexPadded64","number","isValidHex","hasNonHexId","proof","getEncodedTokenV3","token","removeDleq","stripDleq","v3TokenObj","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","hexToBytes","tokenFromTemplate","template","proofs","decodedToken","getDecodedToken","handleTokens","encodedToken","parsedV3Token","entry","tokenObj","uInt8Token","tokenData","verifyKeysetId","deriveKeysetId","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","hash","sha256","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","sumProofs","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","newP","hasValidDleq","dleq","verifyDLEQProof_reblind","pointFromHex","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","LogLevel","NULL_LOGGER","_ConsoleLogger","minLevel","level","context","levelPrefix","interpolatedMessage","usedKeys","processedContext","match","filteredContext","consoleMethod","ConsoleLogger","measureTime","start","ConnectionManager","logger","newConn","WSConnection","resolve","reject","err","e","cb","method","params","subId","callback","errorCallback","fn","parsed","notification","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","contentType","rawText","errorMessage","errorData","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","o","num","path","isProtectedEndpoint","mintMeltInfo","CashuMint","_mintUrl","_customRequest","authTokenGetter","mintUrl","customRequest","mintLogger","swapPayload","blindAuthToken","requestInstance","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","keysetId","restorePayload","wsSegment","BlindedMessage","B_","isOutputDataFactory","OutputData","blindedMessage","blidingFactor","secret","sig","blindSignature","A","constructProofFromPromise","serializeProof","p2pk","customSplit","cairoSend","pubkeys","n_sigs","n_sigs_refund","newSecret","randomBytes","secretBytes","r","blindMessage","randomHex","seed","counter","deriveSecret","secretBytesAsHex","utf8SecretBytes","deterministicR","deriveBlindingFactor","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","keysets","activeKeysets","activeKeyset","unitKeysets","forceRefresh","requireDleq","outputAmounts","pubkey","privkey","outputData","cairoReceive","newOutputData","swapTransaction","signatures","d","orderedProofs","s","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","sendRes","keep","send","serialized","amountToSend","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","biggerIndex","nextBiggerExFee","rightIndex","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","target","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","sumPPK","nInputs","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepProofs","sendProofs","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","amounts","outputs","signatureMap","matchingSig","res","supported","quoteId","baseRes","privateKey","newBlindingData","blindedMessages","mintQuoteSignature","signMintQuote","invoice","meltQuote","millisatPartialAmount","meltOptions","proofsToSend","signP2PKProofs","witness","meltResponse","customOutputData","total","keepAmount","factory","cairoProveProofs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","hashToCurve","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","quoteIds","proofMap","y","ys","CashuAuthMint","clearAuthToken","CashuAuthWallet","authProofs","getEncodedAuthToken","getBlindedAuthToken","authMint"],"mappings":"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"}