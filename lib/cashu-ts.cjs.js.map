{"version":3,"file":"cashu-ts.cjs.js","sources":["../src/base64.ts","../src/cbor.ts","../src/model/PaymentRequest.ts","../src/utils/Constants.ts","../src/utils.ts","../src/ws.ts","../src/logger.ts","../src/WSConnection.ts","../src/model/types/mint/responses.ts","../src/model/types/wallet/paymentRequests.ts","../src/model/Errors.ts","../src/request.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/CashuMint.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/CashuWallet.ts","../src/auth/CashuAuthMint.ts","../src/auth/CashuAuthWallet.ts","../src/auth/index.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Buffer.from(uint8array).toString('base64');\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Buffer.from(bytes)\n\t\t.toString('base64')\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Buffer.from(base64String, 'base64');\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Buffer.from(jsonString).toString('base64'));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Buffer.from(base64urlToBase64(base64String), 'base64').toString();\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n};\n","type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\ttype RawPaymentRequest,\n\ttype RawTransport,\n\ttype NUT10Option,\n\ttype PaymentRequestTransport,\n\ttype PaymentRequestTransportType,\n} from './types';\nimport { Buffer } from 'buffer';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Buffer.from(data).toString('base64');\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * Per protocol definition since tokenV3 tokens have a prefix and a version number.\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { Buffer } from 'buffer';\nimport { verifyDLEQProof_reblind } from './crypto/client/NUT12';\nimport { type DLEQ, pointFromHex } from './crypto/common/index';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from './model/PaymentRequest';\nimport {\n\ttype DeprecatedToken,\n\ttype Keys,\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedDLEQ,\n\ttype Token,\n\ttype TokenV4Template,\n\ttype V4DLEQTemplate,\n\ttype V4InnerToken,\n\ttype V4ProofTemplate,\n} from './model/types/index';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants';\n\n/**\n * Splits the amount into denominations of the provided @param keyset.\n *\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts.\n * @throws Error if @param split amount is greater than @param value amount.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\t\tif (totalSplitAmount > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalSplitAmount} > ${value}`);\n\t\t}\n\t\tif (split.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\t\tvalue = value - sumArray(split);\n\t} else {\n\t\tsplit = [];\n\t}\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split?.push(amt);\n\t\tvalue %= amt;\n\t});\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\tconst sortedAmountsWeWant = amountsWeWant.sort((a, b) => a - b);\n\treturn sortedAmountsWeWant;\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nfunction isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(token: string) {\n\t// remove prefixes\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn handleTokens(token);\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\tconst decodedToken = tokenFromTemplate(tokenData);\n\t\treturn decodedToken;\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Recomputes the ID for the provided keyset and verifies it matches the ID provided by the Mint.\n *\n * @param keys The keyset to be verified.\n * @returns True if the verification succeeded, false otherwise.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\treturn deriveKeysetId(keys.keys) === keys.id;\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @returns\n */\nexport function deriveKeysetId(keys: Keys) {\n\tconst pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\tif (\n\t\t!verifyDLEQProof_reblind(\n\t\t\tnew TextEncoder().encode(proof.secret),\n\t\t\tdleq,\n\t\t\tpointFromHex(proof.C),\n\t\t\tpointFromHex(key),\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport const LogLevel = {\n\tFATAL: 'FATAL',\n\tERROR: 'ERROR',\n\tWARN: 'WARN',\n\tINFO: 'INFO',\n\tDEBUG: 'DEBUG',\n\tTRACE: 'TRACE',\n} as const;\n\n/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\nexport interface Logger {\n\tfatal(message: string, context?: Record<string, unknown>): void;\n\terror(message: string, context?: Record<string, unknown>): void;\n\twarn(message: string, context?: Record<string, unknown>): void;\n\tinfo(message: string, context?: Record<string, unknown>): void;\n\tdebug(message: string, context?: Record<string, unknown>): void;\n\ttrace(message: string, context?: Record<string, unknown>): void;\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void;\n}\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\tfatal() {},\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\tpublic static readonly SEVERITY: Record<LogLevel, number> = {\n\t\t[LogLevel.FATAL]: 0,\n\t\t[LogLevel.ERROR]: 1,\n\t\t[LogLevel.WARN]: 2,\n\t\t[LogLevel.INFO]: 3,\n\t\t[LogLevel.DEBUG]: 4,\n\t\t[LogLevel.TRACE]: 5,\n\t};\n\tconstructor(minLevel: LogLevel = LogLevel.INFO) {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate logToConsole(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tif (ConsoleLogger.SEVERITY[level] > ConsoleLogger.SEVERITY[this.minLevel]) return;\n\t\tconst levelPrefix = `[${level}] `;\n\t\tlet interpolatedMessage = message;\n\t\tconst usedKeys = new Set<string>();\n\t\tif (context) {\n\t\t\tconst processedContext = Object.fromEntries(\n\t\t\t\tObject.entries(context).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue instanceof Error ? { message: value.message, stack: value.stack } : value,\n\t\t\t\t]),\n\t\t\t);\n\t\t\tinterpolatedMessage = message.replace(/\\{(\\w+)\\}/g, (match: string, key: string) => {\n\t\t\t\tif (key in processedContext && processedContext[key] !== undefined) {\n\t\t\t\t\tusedKeys.add(key);\n\t\t\t\t\tconst value: unknown = processedContext[key];\n\t\t\t\t\tif (typeof value === 'string') return value;\n\t\t\t\t\tif (typeof value === 'number' || typeof value === 'boolean') return value.toString();\n\t\t\t\t\tif (value == null) return '';\n\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tconst filteredContext = Object.fromEntries(\n\t\t\t\tObject.entries(processedContext).filter(([key]) => !usedKeys.has(key)),\n\t\t\t);\n\t\t\tconst consoleMethod = this.getConsoleMethod(level);\n\t\t\tif (Object.keys(filteredContext).length > 0) {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage, filteredContext);\n\t\t\t} else {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.getConsoleMethod(level)(levelPrefix + interpolatedMessage);\n\t\t}\n\t}\n\t// Note: NOT static as test suite needs to spy on the output\n\tprivate getConsoleMethod(level: LogLevel): (message: string, ...args: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase LogLevel.FATAL:\n\t\t\tcase LogLevel.ERROR:\n\t\t\t\treturn console.error;\n\t\t\tcase LogLevel.WARN:\n\t\t\t\treturn console.warn;\n\t\t\tcase LogLevel.INFO:\n\t\t\t\treturn console.info;\n\t\t\tcase LogLevel.DEBUG:\n\t\t\t\treturn console.debug;\n\t\t\tcase LogLevel.TRACE:\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\t// We could throw, but that's a bit aggressive for a logging class\n\t\t\t\t// so just use a regular console.log()\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\t// Interface methods\n\tfatal(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.FATAL, message, context);\n\t}\n\terror(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.ERROR, message, context);\n\t}\n\twarn(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.WARN, message, context);\n\t}\n\tinfo(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.INFO, message, context);\n\t}\n\tdebug(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.DEBUG, message, context);\n\t}\n\ttrace(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.TRACE, message, context);\n\t}\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { MessageQueue } from './utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from './model/types';\nimport { type OnOpenError, type OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint.\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * Keyset id for indicating which public key was used to sign the blinded message.\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi.\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature.\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof.\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","import { type Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\nimport { type Logger, NULL_LOGGER } from './logger';\nimport { type ApiError } from './model/types/mint/responses';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\trequestLogger.debug?.('HTTP request', {\n\t\t\tmethod: options.method ?? 'GET',\n\t\t\turl: endpoint,\n\t\t\tbodyLength: body?.length ?? 0,\n\t\t\theaders,\n\t\t});\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tconst contentType = response.headers.get('content-type') ?? '';\n\tconst rawText = await response.text().catch(() => undefined);\n\n\tif (!response.ok) {\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tlet parsed: unknown;\n\t\tif (contentType.includes('application/json') && rawText) {\n\t\t\ttry {\n\t\t\t\tparsed = JSON.parse(rawText);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t} else if (rawText && rawText.trim().startsWith('{')) {\n\t\t\ttry {\n\t\t\t\tparsed = JSON.parse(rawText);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\tlet errorData: ApiError | undefined =\n\t\t\tparsed && typeof parsed === 'object' ? (parsed as ApiError) : undefined;\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\terrorData &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof (errorData as any).code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof (errorData as any).detail === 'string'\n\t\t) {\n\t\t\t// Specific mint operation error\n\t\t\tthrow new MintOperationError((errorData as any).code, (errorData as any).detail);\n\t\t}\n\n\t\tif (errorData) {\n\t\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\t\terrorMessage = errorData.error;\n\t\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\t\terrorMessage = errorData.detail;\n\t\t\t}\n\t\t} else if (rawText && rawText.trim().length > 0) {\n\t\t\terrorMessage = rawText.trim();\n\t\t} else {\n\t\t\terrorMessage = 'bad response';\n\t\t}\n\t\trequestLogger.error?.('HTTP error response', {\n\t\t\tmethod: options.method ?? 'GET',\n\t\t\turl: endpoint,\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\tcontentType,\n\t\t\tbodySnippet: rawText ? rawText.slice(0, 2000) : undefined,\n\t\t});\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\tif (rawText && rawText.length > 0) {\n\t\t\treturn JSON.parse(rawText);\n\t\t}\n\t\t// empty 204/205\n\t\treturn null;\n\t} catch (err) {\n\t\trequestLogger.error?.('Failed to parse HTTP response', {\n\t\t\terr: err instanceof Error ? err.message : String(err),\n\t\t\turl: endpoint,\n\t\t\tstatus: response.status,\n\t\t\tcontentType,\n\t\t\tbodySnippet: rawText ? rawText.slice(0, 2000) : undefined,\n\t\t});\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { PartialMeltQuoteResponse } from '../model/types/index';\nimport { MeltQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../model/types/index';\nimport { MintQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\tprivate readonly _protectedEnpoints?: {\n\t\tcache: {\n\t\t\t[url: string]: boolean;\n\t\t};\n\t\tapiReturn: Array<{ method: 'GET' | 'POST'; regex: RegExp; cachedValue?: boolean }>;\n\t};\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t\tif (info.nuts[22]) {\n\t\t\tthis._protectedEnpoints = {\n\t\t\t\tcache: {},\n\t\t\t\tapiReturn: info.nuts[22].protected_endpoints.map((o) => ({\n\t\t\t\t\tmethod: o.method,\n\t\t\t\t\tregex: new RegExp(o.path),\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(path: string) {\n\t\tif (!this._protectedEnpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof this._protectedEnpoints.cache[path] === 'boolean') {\n\t\t\treturn this._protectedEnpoints.cache[path];\n\t\t}\n\t\tconst isProtectedEndpoint = this._protectedEnpoints.apiReturn.some((e) => e.regex.test(path));\n\t\tthis._protectedEnpoints.cache[path] = isProtectedEndpoint;\n\t\treturn isProtectedEndpoint;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n}\n","import { ConnectionManager, type WSConnection } from './WSConnection';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n} from './model/types/index';\nimport { MeltQuoteState } from './model/types/index';\nimport request, { setRequestLogger } from './request';\nimport { isObj, joinUrls, sanitizeUrl } from './utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from './legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from './legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER } from './logger';\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented\n * by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authTokenGetter?: () => Promise<string>;\n\tprivate _checkNut22 = false;\n\tprivate _logger: Logger;\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t * @param [authTokenGetter] A function that is called by the CashuMint instance to obtain a NUT-22\n\t *   BlindedAuthToken (e.g. from a database or localstorage)\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t\tauthTokenGetter?: () => Promise<string>,\n\t\toptions?: {\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t\tif (authTokenGetter) {\n\t\t\tthis._checkNut22 = true;\n\t\t\tthis._authTokenGetter = authTokenGetter;\n\t\t}\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\t//TODO: v3 - refactor CashuMint to take two or less args.\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t\tlogger?: Logger,\n\t): Promise<GetInfoResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest, this._logger);\n\t}\n\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param mintUrl\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest\n\t * @returns Signed outputs.\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/swap');\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt11');\n\t\treturn CashuMint.createMintQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @param customRequest\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt11');\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt11');\n\t\treturn CashuMint.createMeltQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens\n\t * matching its amount + fees.\n\t *\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt11');\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: SerializedBlindedMessage[];\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\tasync handleBlindAuth(path: string) {\n\t\tif (!this._checkNut22) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (info.requiresBlindAuthToken(path)) {\n\t\t\tif (!this._authTokenGetter) {\n\t\t\t\tthrow new Error('Can not call a protected endpoint without authProofGetter');\n\t\t\t}\n\t\t\treturn this._authTokenGetter();\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport { CashuMint };\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type ProjPointType } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: ProjPointType<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: ProjPointType<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { blindMessage, constructProofFromPromise, serializeProof } from '../crypto/client/index';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { type DLEQ, pointFromHex } from '../crypto/common/index';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '../crypto/client/NUT09';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createCairoData(\n\t\tcairoSend: { programHash: string; outputHash: string },\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleCairoData(cairoSend, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\t// Standardize pubkey (backwards compat), clamp n_sigs between 1 and total pubkeys\n\t\t// clamp n_sigs_refund between 1 and total refundKeys, and create secret\n\t\tconst pubkeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst n_sigs: number = Math.max(1, Math.min(p2pk.requiredSignatures || 1, pubkeys.length));\n\t\tconst n_sigs_refund: number = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures || 1, p2pk.refundKeys ? p2pk.refundKeys.length : 1),\n\t\t);\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: pubkeys[0], // Primary key\n\t\t\t\ttags: [],\n\t\t\t},\n\t\t];\n\t\tif (p2pk.locktime) {\n\t\t\tnewSecret[1].tags.push(['locktime', String(p2pk.locktime)]); // NUT-10 string\n\t\t}\n\t\tif (pubkeys.length > 1) {\n\t\t\tnewSecret[1].tags.push(['pubkeys', ...pubkeys.slice(1)]); // Additional keys\n\t\t\tif (n_sigs > 1) {\n\t\t\t\t// 1 is the default, so we can save space if not multisig\n\t\t\t\tnewSecret[1].tags.push(['n_sigs', String(n_sigs)]); // NUT-10 string\n\t\t\t}\n\t\t}\n\t\tif (p2pk.refundKeys) {\n\t\t\tnewSecret[1].tags.push(['refund', ...p2pk.refundKeys]);\n\t\t\tif (n_sigs_refund > 1) {\n\t\t\t\t// 1 is the default, so we can save space if not multisig\n\t\t\t\tnewSecret[1].tags.push(['n_sigs_refund', String(n_sigs_refund)]); // NUT-10 string\n\t\t\t}\n\t\t}\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createSingleCairoData(\n\t\tcairoSend: { programHash: string; outputHash: string },\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'Cairo',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: cairoSend.programHash,\n\t\t\t\ttags: [['program_output', cairoSend.outputHash]],\n\t\t\t},\n\t\t];\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n}\n","import { signP2PKProofs } from './crypto/client/NUT11';\nimport { hashToCurve } from './crypto/common/index';\nimport { type CashuMint } from './CashuMint';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER, measureTime } from './logger';\nimport type {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSwapOptions,\n\tMeltPayload,\n\tMeltProofsResponse,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tMintKeys,\n\tMintKeyset,\n\tMintPayload,\n\tMintQuotePayload,\n\tProof,\n\tSendResponse,\n\tToken,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n} from './model/types/index';\nimport { MintQuoteState, MeltQuoteState } from './model/types/index';\nimport { type SubscriptionCanceller } from './model/types/wallet/websocket';\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs,\n\tverifyKeysetId,\n} from './utils';\nimport { signMintQuote } from './crypto/client/NUT20';\nimport {\n\tOutputData,\n\ttype OutputDataFactory,\n\ttype OutputDataLike,\n\tisOutputDataFactory,\n} from './model/OutputData';\nimport { cairoProveProofs } from './crypto/client/NUTXX';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet. This class should act as the entry point for this library.\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\tprivate _logger: Logger;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls.\n\t * @param options.unit Optionally set unit (default is 'sat')\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo Mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget Target number proofs per denomination (default: see @constant\n\t *   DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that\n\t *   produce proofs to be kept (change, etc.). This can lead to poor performance, in which case\n\t *   the seed should be directly provided.\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getMintInfo();\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active && k.unit === this._unit);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tkeysets.keysets.forEach((k) => {\n\t\t\tif (!verifyKeysetId(k)) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${k.id}`);\n\t\t\t}\n\t\t});\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tif (!verifyKeysetId(keys.keysets[0])) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${keys.keysets[0].id}`);\n\t\t\t}\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the\n\t * first token in the token array)\n\t *\n\t * @param {string | Token} token - Cashu token, either as string or decoded.\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing.\n\t * @returns New token with newly created proofs, token entries that had errors.\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Proof[]> {\n\t\tconst {\n\t\t\trequireDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t} = options || {};\n\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: OutputDataLike[] | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = await this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation.\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Proof[], options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t} = options || {};\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees,\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\tconst sendRes = await this.swap(amount, proofs, options);\n\t\t\tconst { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(proofs: Proof[], amountToSend: number, includeFees = false): SendResponse {\n\t\t// Init vars\n\t\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\t\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\t\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\t\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\t\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\t\tconst exactMatch = false; // Allows close match (> amountToSend + fee)\n\t\tconst timer = measureTime(); // start the clock\n\t\tlet bestSubset: ProofWithFee[] | null = null;\n\t\tlet bestDelta = Infinity;\n\t\tlet bestAmount = 0;\n\t\tlet bestFeePPK = 0;\n\n\t\t/**\n\t\t * Helper Functions.\n\t\t */\n\t\tinterface ProofWithFee {\n\t\t\tproof: Proof;\n\t\t\texFee: number;\n\t\t\tppkfee: number;\n\t\t}\n\t\t// Calculate net amount after fees\n\t\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t\t};\n\t\t// Shuffle array for randomization\n\t\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\t\tconst shuffled = [...array];\n\t\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t\t}\n\t\t\treturn shuffled;\n\t\t};\n\t\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\t\tconst binarySearchIndex = (\n\t\t\tarr: ProofWithFee[],\n\t\t\tvalue: number,\n\t\t\tlessOrEqual: boolean,\n\t\t): number | null => {\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length - 1,\n\t\t\t\tresult: number | null = null;\n\t\t\twhile (left <= right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tconst midValue = arr[mid].exFee;\n\t\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\t\tresult = mid;\n\t\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\t\telse right = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\t\telse left = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t\t};\n\t\t// Insert into array of ProofWithFee objects sorted by exFee\n\t\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\t\tconst value = obj.exFee;\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length;\n\t\t\twhile (left < right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\t\telse right = mid;\n\t\t\t}\n\t\t\tarr.splice(left, 0, obj);\n\t\t};\n\t\t// \"Delta\" is the excess over amountToSend including fees\n\t\t// plus a tiebreaker to favour lower PPK keysets\n\t\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\t\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\t\treturn amount + feePPK / 1000 - amountToSend;\n\t\t};\n\n\t\t/**\n\t\t * Pre-processing.\n\t\t */\n\t\tlet totalAmount = 0;\n\t\tlet totalFeePPK = 0;\n\t\tconst proofWithFees = proofs.map((p) => {\n\t\t\tconst ppkfee = this.getProofFeePPK(p);\n\t\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t\t// Sum all economical proofs (filtered below)\n\t\t\tif (!includeFees || exFee > 0) {\n\t\t\t\ttotalAmount += p.amount;\n\t\t\t\ttotalFeePPK += ppkfee;\n\t\t\t}\n\t\t\treturn obj;\n\t\t});\n\n\t\t// Filter uneconomical proofs (totals computed above)\n\t\tlet spendableProofs = includeFees\n\t\t\t? proofWithFees.filter((obj) => obj.exFee > 0)\n\t\t\t: proofWithFees;\n\n\t\t// Sort by exFee ascending\n\t\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t\t// Remove proofs too large to be useful and adjust totals\n\t\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\t\tif (spendableProofs.length > 0) {\n\t\t\tlet endIndex;\n\t\t\tif (exactMatch) {\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t\t} else {\n\t\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\t\tif (biggerIndex !== null) {\n\t\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\t\tif (rightIndex === null) {\n\t\t\t\t\t\tthrow new Error('Unexpected null rightIndex in binary search');\n\t\t\t\t\t}\n\t\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust totals for removed proofs\n\t\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t\t}\n\t\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t\t}\n\n\t\t// Validate using precomputed totals\n\t\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\t\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\t// Max acceptable amount for non-exact matches\n\t\tconst maxOverAmount = Math.min(\n\t\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\t\tamountToSend + MAX_OVRAMT,\n\t\t\ttotalNetSum,\n\t\t);\n\n\t\t/**\n\t\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees\n\t\t * are dynamic, based on number of proofs (PPK), so we perform all calculations based on net\n\t\t * amounts.\n\t\t */\n\t\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t\t// PHASE 1: Randomized Greedy Selection\n\t\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t\t// for exact match or the first amount over target otherwise\n\t\t\tconst S: ProofWithFee[] = [];\n\t\t\tlet amount = 0;\n\t\t\tlet feePPK = 0;\n\t\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\t\tS.push(obj);\n\t\t\t\tamount = newAmount;\n\t\t\t\tfeePPK = newFeePPK;\n\t\t\t\tif (netSum >= amountToSend) break;\n\t\t\t}\n\n\t\t\t// PHASE 2: Local Improvement\n\t\t\t// Examine all the amounts found in the first phase, and find the\n\t\t\t// amount not in the current solution (others), which would get us\n\t\t\t// closest to the amountToSend.\n\n\t\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t\t// Using array.includes() would be way slower: O(n*m)\n\t\t\tconst SSet = new Set(S);\n\t\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t\t// Generate a random order for accessing the trial subset ('S')\n\t\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t\t0,\n\t\t\t\tMAX_P2SWAP,\n\t\t\t);\n\t\t\tfor (const i of indices) {\n\t\t\t\t// Exact or acceptable close match solution found?\n\t\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\t\tif (\n\t\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\t\tconst objP = S[i];\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t\t// not replace larger unless it closes on the target\n\t\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\t\tif (qIndex !== null) {\n\t\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update best solution\n\t\t\tconst delta = calculateDelta(amount, feePPK);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tthis._logger.debug(\n\t\t\t\t\t'selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}',\n\t\t\t\t\t{ trial, amount, delta },\n\t\t\t\t);\n\t\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\t\tbestDelta = delta;\n\t\t\t\tbestAmount = amount;\n\t\t\t\tbestFeePPK = feePPK;\n\n\t\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t\t// optimal fee solutions more consistently\n\t\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if solution is acceptable\n\t\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\t\tif (\n\t\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Time limit reached?\n\t\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\t\tif (exactMatch) {\n\t\t\t\t\tthrow new Error('Proof selection took too long. Try again with a smaller proof set.');\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return Result\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t\tthis._logger.info('Proof selection took {time}ms', { time: timer.elapsed() });\n\t\t\treturn { keep, send: bestProofs };\n\t\t}\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof) {\n\t\tconst keyset = this._keysets.find((k) => k.id === proof.id);\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Could not get fee. No keyset found for keyset id: ${proof.id}`);\n\t\t}\n\t\treturn keyset?.input_fee_ppk || 0;\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0,\n\t\t\t),\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens if no amount is specified, the amount is implied by the\n\t * cumulative amount of all proofs if both amount and preference are set, but the preference\n\t * cannot fulfill the amount, then we use the default split.\n\t *\n\t * @param {SwapOptions} [options] - Optional parameters for configuring the swap operation.\n\t * @returns Promise of the change- and send-proofs.\n\t */\n\tasync swap(amount: number, proofs: Proof[], options?: SwapOptions): Promise<SendResponse> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst {\n\t\t\tincludeFees,\n\t\t\tkeysetId,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tproofsWeHave,\n\t\t\toutputData,\n\t\t\tp2pk,\n\t\t\tcairoSend,\n\t\t\tcairoReceive,\n\t\t} = options || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t}\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\t// input selection, needs fees because of the swap\n\t\tconst { keep: keepProofs, send: sendProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\ttrue, // inc. fees\n\t\t);\n\n\t\tconst amountToKeep = sumProofs(sendProofs) - this.getFeesForProofs(sendProofs) - amountToSend;\n\n\t\tif (amountToKeep < 0) {\n\t\t\tthrow new Error('Not enough balance to send');\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && !proofsWeHave) {\n\t\t\tkeepAmounts = splitAmount(amountToKeep, keyset.keys);\n\t\t} else if (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(sendProofs) > amountAvailable) {\n\t\t\tthis._logger.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tsendProofs,\n\t\t\t\t)} | length: ${sendProofs.length}`,\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts,\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = await this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tsendProofs,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk,\n\t\t\tcairoReceive,\n\t\t\tcairoSend,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Proof[] = [];\n\t\tconst splitProofsToSend: Proof[] = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...splitProofsToKeep, ...keepProofs],\n\t\t\tsend: splitProofsToSend,\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. keysetIds can be loaded with\n\t *   `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create blank amounts for unknown restore amounts\n\t\tconst amounts = Array(count).fill(1);\n\t\tconst outputData = OutputData.createDeterministicData(\n\t\t\tamounts.length,\n\t\t\tthis._seed,\n\t\t\tstart,\n\t\t\tkeys,\n\t\t\tamounts,\n\t\t);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote form the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this.unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = (await this.getMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (typeof res.pubkey !== 'string') {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t} else {\n\t\t\tconst pubkey = res.pubkey;\n\t\t\treturn { ...res, pubkey, amount: res.amount || amount, unit: res.unit || this.unit };\n\t\t}\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - Containing the quote ID and unlocking private key (when quote\n\t *   is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string },\n\t): Promise<Proof[]>;\n\tasync mintProofs(amount: number, quote: string, options?: MintProofOptions): Promise<Proof[]>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: [],\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: OutputData[] = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\t\tlet mintPayload: MintPayload;\n\t\tif (typeof quote !== 'string') {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\t\tconst mintQuoteSignature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t\tmintPayload = {\n\t\t\t\toutputs: blindedMessages,\n\t\t\t\tquote: quote.quote,\n\t\t\t\tsignature: mintQuoteSignature,\n\t\t\t};\n\t\t} else {\n\t\t\tmintPayload = {\n\t\t\t\toutputs: newBlindingData.map((d) => d.blindedMessage),\n\t\t\t\tquote: quote,\n\t\t\t};\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this.unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;\n\tasync checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory,\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t};\n\t}\n\n\t/**\n\t * Creates a split payload.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofsToSend Proofs to split*\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param privkey? Will create a signature on the @param proofsToSend secrets if set.\n\t * @param customOutputData? Optionally specify your own OutputData (blinded messages)\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @returns\n\t */\n\tprivate async createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Proof[],\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: OutputDataLike[] | OutputDataFactory;\n\t\t\tsend?: OutputDataLike[] | OutputDataFactory;\n\t\t},\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tcairoReceive?: {\n\t\t\texecutable: string;\n\t\t\tprogramInput: bigint[];\n\t\t},\n\t\tcairoSend?: {\n\t\t\tprogramHash: string;\n\t\t\toutputHash: string;\n\t\t},\n\t): Promise<SwapTransaction> {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys,\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: OutputDataLike[] = [];\n\t\tlet sendOutputData: OutputDataLike[] = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory,\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk,\n\t\t\t\tcairoSend,\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t} else if (cairoReceive) {\n\t\t\tproofsToSend = await cairoProveProofs(\n\t\t\t\tproofsToSend,\n\t\t\t\tcairoReceive.executable,\n\t\t\t\tcairoReceive.programInput,\n\t\t\t);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputData.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputData.length }, () => false),\n\t\t];\n\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage),\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Proof[]): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts.\n\t *\n\t * @param amount Array of amounts to create blinded messages for.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @param factory? Optionally specify a custom function that produces OutputData (blinded\n\t *   messages)\n\t * @returns Blinded messages, secrets, rs, and amounts.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: number[],\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t},\n\t\tcairoSend?: {\n\t\t\tprogramHash: string;\n\t\t\toutputHash: string;\n\t\t},\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet outputData: OutputDataLike[];\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData({ pubkey }, amount, keyset, outputAmounts);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (cairoSend) {\n\t\t\toutputData = OutputData.createCairoData(cairoSend, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve See:\n\t * https://github.com/cashubtc/nuts/blob/main/08.md.\n\t *\n\t * @param amount Amount to cover with blank outputs.\n\t * @param keysetId Mint keysetId.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @returns Blinded messages, secrets, and rs.\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\tconst amounts = count ? Array(count).fill(1) : [];\n\t\treturn this.createOutputData(\n\t\t\tamounts.length,\n\t\t\tkeyset,\n\t\t\tcounter,\n\t\t\tundefined,\n\t\t\tamounts,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfactory,\n\t\t);\n\t}\n}\n\nexport { CashuWallet };\n","import {\n\ttype BlindAuthMintPayload,\n\ttype BlindAuthMintResponse,\n\ttype MintActiveKeys,\n\ttype MintAllKeysets,\n} from '../model/types';\nimport request from '../request';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\n\n/**\n * Class represents Cashu Auth Mint API. This class contains Lower level functions that are\n * implemented by CashuAuthWallet.\n */\nclass CashuAuthMint {\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: BlindAuthMintPayload,\n\t\tclearAuthToken: string,\n\t\tcustomRequest?: typeof request,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers = {\n\t\t\t'Clear-auth': `${clearAuthToken}`,\n\t\t};\n\t\tconst data = await requestInstance<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: BlindAuthMintPayload, clearAuthToken: string) {\n\t\treturn CashuAuthMint.mint(this._mintUrl, mintPayload, clearAuthToken, this._customRequest);\n\t}\n\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(mintUrl, '/v1/auth/blind/keys', keysetId)\n\t\t\t\t: joinUrls(mintUrl, '/v1/auth/blind/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuAuthMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuAuthMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n}\n\nexport { CashuAuthMint };\n","import { OutputData } from '../model/OutputData';\nimport {\n\ttype BlindAuthMintPayload,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype Proof,\n} from '../model/types';\nimport { hasValidDleq } from '../utils';\nimport { type CashuAuthMint } from './CashuAuthMint';\n\n/**\n * Class that represents a Cashu NUT-22 wallet.\n */\nclass CashuAuthWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _unit = 'auth';\n\n\tmint: CashuAuthMint;\n\n\t/**\n\t * @param mint NUT-22 auth mint instance.\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t */\n\tconstructor(\n\t\tmint: CashuAuthMint,\n\t\toptions?: {\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t}\n\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param clearAuthToken ClearAuthToken to mint.\n\t * @param options.keysetId? Optionally set keysetId for blank outputs for returned change.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tclearAuthToken: string,\n\t\toptions?: {\n\t\t\tkeysetId?: string;\n\t\t},\n\t): Promise<Proof[]> {\n\t\tconst keyset = await this.getKeys(options?.keysetId);\n\t\tconst outputData = OutputData.createRandomData(amount, keyset);\n\n\t\tconst mintPayload: BlindAuthMintPayload = {\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst { signatures } = await this.mint.mint(mintPayload, clearAuthToken);\n\t\tconst authProofs = outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tif (authProofs.some((p) => !hasValidDleq(p, keyset))) {\n\t\t\tthrow new Error('Mint returned auth proofs with invalid DLEQ');\n\t\t}\n\t\treturn authProofs;\n\t}\n}\n\nexport { CashuAuthWallet };\n","import { CashuAuthMint } from './CashuAuthMint';\nimport { CashuAuthWallet } from './CashuAuthWallet';\nimport { encodeJsonToBase64 } from '../base64';\nimport { type Proof } from '../model/types';\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nexport async function getBlindedAuthToken(amount: number, url: string, clearAuthToken: string) {\n\tconst authMint = new CashuAuthMint(url);\n\tconst authWallet = new CashuAuthWallet(authMint);\n\tconst authProofs = await authWallet.mintProofs(amount, clearAuthToken);\n\treturn authProofs.map((p) => getEncodedAuthToken(p));\n}\n\nexport { CashuAuthMint, CashuAuthWallet };\n"],"names":["encodeUint8toBase64Url","bytes","Buffer","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","i","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","nut10","rawRequest","t","type","rawPaymentRequest","transports","encodedRequest","encodedData","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","amt","hasCorrespondingKey","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","p","countWeHave","countWeWant","amountDiff","k","bytesToNumber","hexToNumber","bytesToHex","hex","numberToHexPadded64","number","isValidHex","hasNonHexId","proof","getEncodedTokenV3","token","removeDleq","stripDleq","v3TokenObj","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","hexToBytes","tokenFromTemplate","template","proofs","decodedToken","getDecodedToken","handleTokens","encodedToken","parsedV3Token","entry","tokenObj","uInt8Token","tokenData","verifyKeysetId","deriveKeysetId","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","hash","sha256","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","sumProofs","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","newP","hasValidDleq","dleq","verifyDLEQProof_reblind","pointFromHex","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","LogLevel","NULL_LOGGER","_ConsoleLogger","minLevel","level","context","levelPrefix","interpolatedMessage","usedKeys","processedContext","match","filteredContext","consoleMethod","ConsoleLogger","measureTime","start","ConnectionManager","logger","newConn","WSConnection","resolve","reject","err","e","cb","method","params","subId","callback","errorCallback","fn","parsed","notification","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","contentType","rawText","errorMessage","errorData","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","o","num","path","isProtectedEndpoint","mintMeltInfo","CashuMint","_mintUrl","_customRequest","authTokenGetter","mintUrl","customRequest","mintLogger","swapPayload","blindAuthToken","requestInstance","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","keysetId","restorePayload","wsSegment","BlindedMessage","B_","isOutputDataFactory","OutputData","blindedMessage","blidingFactor","secret","sig","blindSignature","A","constructProofFromPromise","serializeProof","p2pk","customSplit","cairoSend","pubkeys","n_sigs","n_sigs_refund","newSecret","randomBytes","secretBytes","r","blindMessage","randomHex","seed","counter","deriveSecret","secretBytesAsHex","utf8SecretBytes","deterministicR","deriveBlindingFactor","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","keysets","activeKeysets","activeKeyset","unitKeysets","forceRefresh","requireDleq","outputAmounts","pubkey","privkey","outputData","cairoReceive","newOutputData","swapTransaction","signatures","d","orderedProofs","s","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","sendRes","keep","send","serialized","amountToSend","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","biggerIndex","nextBiggerExFee","rightIndex","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","target","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","sumPPK","nInputs","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepProofs","sendProofs","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","amounts","outputs","signatureMap","matchingSig","res","supported","quoteId","baseRes","privateKey","newBlindingData","blindedMessages","mintQuoteSignature","signMintQuote","invoice","meltQuote","millisatPartialAmount","meltOptions","proofsToSend","signP2PKProofs","witness","meltResponse","customOutputData","total","keepAmount","factory","cairoProveProofs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","hashToCurve","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","quoteIds","proofMap","y","ys","CashuAuthMint","clearAuthToken","CashuAuthWallet","authProofs","getEncodedAuthToken","getBlindedAuthToken","authMint"],"mappings":"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"}