{"version":3,"file":"common.cjs.js","sources":["../../src/crypto/common/index.ts"],"sourcesContent":["import { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils';\nimport { Buffer } from 'buffer';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: ProjPointType<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: ProjPointType<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK' | 'Cairo';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport type Witness = {\n\tsignatures: string[];\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): ProjPointType<bigint> {\n\tconst msgToHash = sha256(Buffer.concat([DOMAIN_SEPARATOR, secret]));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Buffer.concat([msgToHash, counterBytes]));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Buffer.concat([new Uint8Array([0x02]), hash])));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<ProjPointType<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\tconst e = sha256(new TextEncoder().encode(e_));\n\treturn e;\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.ProjectivePoint.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.ProjectivePoint.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomPrivateKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn KEYSET_VERSION + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n"],"names":["DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","Buffer","counter","maxIterations","i","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","bytes","secp256k1","hex","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","bytesToNumber","encodeBase64toUint8","createRandomPrivateKey","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","deriveKeysetId","keys","mapBigInt","k","pubkeysConcat","a","b","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray"],"mappings":"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"}