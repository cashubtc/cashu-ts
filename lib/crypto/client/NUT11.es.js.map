{"version":3,"file":"NUT11.es.js","sources":["../../../src/crypto/client/NUT11.ts"],"sourcesContent":["import { type PrivKey, bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { parseSecret } from '../common/NUT10';\nimport { type Secret, type Witness } from '../common/index';\nimport { type P2PKWitness, type Proof } from '../../model/types/index';\nimport { type BlindedMessage } from './index';\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey);\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness as string | P2PKWitness);\n\t// See if any of the signatures belong to this pubkey.\n\t// We need to do this as Schnorr signatures are non-deterministic.\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? sigFlagTag[1] : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @type {array} of Signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as Witness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param beStrict - (Default: false) Throws Error if any signing attempt fails.\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tbeStrict = false,\n): Proof[] => {\n\tconst privateKeys: string[] = Array.isArray(privateKey) ? privateKey : [privateKey];\n\treturn proofs.map((proof, index) => {\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t} catch (error: unknown) {\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tif (beStrict) {\n\t\t\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness as string | P2PKWitness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\tsignatures.push(signature);\n\treturn { ...proof, witness: { signatures } };\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n"],"names":["createP2PKsecret","pubkey","newSecret","bytesToHex","randomBytes","signP2PKSecret","secret","privateKey","msghash","sha256","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hexToBytes","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","parseSecret","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","data","tags","pubkeysTag","tag","pubkeys","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","e","signP2PKProofs","proofs","beStrict","privateKeys","index","signedProof","priv","signP2PKProof","error","message","parsed","witnesses","w","signatures","getSignedOutput","output","getSignedOutputs","outputs","o"],"mappings":"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"}