"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("@noble/curves/abstract/utils"),f=require("@noble/hashes/sha256"),u=require("@noble/curves/secp256k1"),T=require("@noble/hashes/utils"),g=require("../common/NUT10.cjs.js"),E=e=>{const t=["P2PK",{nonce:a.bytesToHex(T.randomBytes(32)),data:e}];return JSON.stringify(t)},w=(e,t)=>{const n=f.sha256(e),s=u.schnorr.sign(n,t);return a.bytesToHex(s)},m=(e,t)=>{const n=f.sha256(e),s=u.schnorr.sign(n,t);return a.bytesToHex(s)},l=(e,t,n)=>{try{const s=f.sha256(t),r=n.length===66?n.slice(2):n;if(u.schnorr.verify(e,s,a.hexToBytes(r)))return!0}catch(s){console.error("verifyP2PKsecret error:",s)}return!1},I=(e,t)=>t.witness?d(t.witness).some(s=>{try{return l(s,t.secret,e)}catch{return!1}}):!1;function h(e){try{const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const n=Math.floor(Date.now()/1e3);return K(t)>n?p(t):S(t)}catch{}return[]}function p(e){const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{data:n,tags:s}=t[1],r=s&&s.find(o=>o[0]==="pubkeys"),i=r&&r.length>1?r.slice(1):[];return[n,...i].filter(Boolean)}function S(e){const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:n}=t[1],s=n&&n.find(r=>r[0]==="refund");return s&&s.length>1?s.slice(1).filter(Boolean):[]}function K(e){const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:n}=t[1],s=n&&n.find(r=>r[0]==="locktime");return s&&s.length>1?parseInt(s[1],10):1/0}function _(e){const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');if(!h(t).length)return 0;const{tags:s}=t[1],r=Math.floor(Date.now()/1e3);if(K(t)>r){const c=s&&s.find(P=>P[0]==="n_sigs");return c&&c.length>1?parseInt(c[1],10):1}const o=s&&s.find(c=>c[0]==="n_sigs_refund");return o&&o.length>1?parseInt(o[1],10):1}function v(e){const t=typeof e=="string"?g.parseSecret(e):e;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:n}=t[1],s=n&&n.find(r=>r[0]==="sigflag");return s&&s.length>1?s[1]:"SIG_INPUTS"}const d=e=>{if(!e)return[];if(typeof e=="string")try{return JSON.parse(e).signatures||[]}catch(t){return console.error("Failed to parse witness string:",t),[]}return e.signatures||[]},B=(e,t,n=!1)=>{const s=Array.isArray(t)?t:[t];return e.map((r,i)=>{let o=r;for(const c of s)try{o=k(o,c)}catch(P){const y=P instanceof Error?P.message:"Unknown error";if(n)throw new Error(`Failed signing proof #${i+1}: ${y}`);console.warn(`Proof #${i+1}: ${y}`)}return o})},k=(e,t)=>{const n=g.parseSecret(e.secret);if(n[0]!=="P2PK")throw new Error("not a P2PK secret");const s=a.bytesToHex(u.schnorr.getPublicKey(t)),r=h(n);if(!r.length||!r.some(P=>P.includes(s)))throw new Error(`Signature not required from [02|03]${s}`);const i=d(e.witness);if(i.some(P=>{try{return l(P,e.secret,s)}catch{return!1}}))throw new Error(`Proof already signed by [02|03]${s}`);const c=w(e.secret,t);return i.push(c),{...e,witness:{signatures:i}}},b=(e,t)=>{const n=e.B_.toHex(!0),s=m(n,t);return e.witness={signatures:[s]},e},W=(e,t)=>e.map(n=>b(n,t));exports.createP2PKsecret=E;exports.getP2PKExpectedKWitnessPubkeys=h;exports.getP2PKLocktime=K;exports.getP2PKNSigs=_;exports.getP2PKSigFlag=v;exports.getP2PKWitnessPubkeys=p;exports.getP2PKWitnessRefundkeys=S;exports.getP2PKWitnessSignatures=d;exports.getSignedOutput=b;exports.getSignedOutputs=W;exports.hasP2PKSignedProof=I;exports.signBlindedMessage=m;exports.signP2PKProof=k;exports.signP2PKProofs=B;exports.signP2PKSecret=w;exports.verifyP2PKSecretSignature=l;
//# sourceMappingURL=NUT11.cjs.js.map
