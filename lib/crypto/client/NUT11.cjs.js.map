{"version":3,"file":"NUT11.cjs.js","sources":["../../../src/crypto/client/NUT11.ts"],"sourcesContent":["import { type PrivKey, bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { parseSecret } from '../common/NUT10';\nimport { type Secret, type Witness } from '../common/index';\nimport { type P2PKWitness, type Proof } from '../../model/types/index';\nimport { type BlindedMessage } from './index';\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey);\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness as string | P2PKWitness);\n\t// See if any of the signatures belong to this pubkey.\n\t// We need to do this as Schnorr signatures are non-deterministic.\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? sigFlagTag[1] : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @type {array} of Signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as Witness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param beStrict - (Default: false) Throws Error if any signing attempt fails.\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tbeStrict = false,\n): Proof[] => {\n\tconst privateKeys: string[] = Array.isArray(privateKey) ? privateKey : [privateKey];\n\treturn proofs.map((proof, index) => {\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t} catch (error: unknown) {\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tif (beStrict) {\n\t\t\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness as string | P2PKWitness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\tsignatures.push(signature);\n\treturn { ...proof, witness: { signatures } };\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n"],"names":["createP2PKsecret","pubkey","newSecret","bytesToHex","randomBytes","signP2PKSecret","secret","privateKey","msghash","sha256","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hexToBytes","e","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","parseSecret","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","data","tags","pubkeysTag","tag","pubkeys","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","signP2PKProofs","proofs","beStrict","privateKeys","index","signedProof","priv","signP2PKProof","error","message","parsed","witnesses","w","signatures","getSignedOutput","output","getSignedOutputs","outputs","o"],"mappings":"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"}