{"version":3,"file":"NUTXX.cjs.js","sources":["../../../src/crypto/client/NUTXX.ts"],"sourcesContent":["import { bytesToHex } from '@noble/curves/abstract/utils';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { BLAKE2s } from '@noble/hashes/blake2';\nimport { type CairoWitness, type Proof } from '../../model/types/index';\nimport { type Secret } from '../common/index';\nimport { parseSecret } from '../common/NUT10';\nimport {\n\tinit,\n\texecute as stwoExecute,\n\tprove as stwoProve,\n\tcontainsPedersenBuiltin,\n} from 'stwo-cairo';\n\n/**\n * Order of the prime field.\n */\nconst P = (1n << 251n) + 17n * (1n << 192n) + 1n;\n\n/**\n * Minimal implementation of a Felt252 type, no operations supported.\n *\n * @link https://www.starknet.io/cairo-book/ch02-02-data-types.html#felt-type\n */\nclass Felt252 {\n\tprivate constructor(private readonly v: bigint) {}\n\n\tstatic fromHex(word: string): Felt252 {\n\t\t// handling -0x.. case\n\t\tlet neg = word.startsWith('-');\n\t\tif (neg) word = word.slice(1);\n\n\t\tlet n = BigInt(word);\n\t\tif (neg) n = -n;\n\n\t\tconst x = ((n % P) + P) % P;\n\t\treturn new Felt252(x);\n\t}\n\n\t// 32-byte little-endian\n\ttoBytesLE(len = 32): Uint8Array {\n\t\tconst out = new Uint8Array(len);\n\t\tlet x = this.v;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tout[i] = Number(x & 0xffn);\n\t\t\tx >>= 8n;\n\t\t}\n\t\treturn out;\n\t}\n}\n\n/**\n * Helper function to create cairoSend object from executable and expected output.\n * \n * @param cairoExecutable - JSON string representing the Cairo executable\n * @param cairoExpectedOutput - Expected output as a number or bigint\n * @returns Object with programHash and outputHash for use in wallet.send\n */\nexport const createCairoDataPayload = (\n\tcairoExecutable: string,\n\tcairoExpectedOutput: number | bigint\n): { programHash: string; outputHash: string } => {\n\tconst executable = JSON.parse(cairoExecutable);\n\tconst bytecode = executable.program.bytecode;\n\tconst programHash = bytesToHex(hashExecutableBytecode(bytecode));\n\tconst outputBigInt = BigInt(cairoExpectedOutput);\n\tconst outputBytes = new Uint8Array(32);\n\tlet temp = outputBigInt;\n\n\tfor (let i = 0; i < 32; i++) {\n\t\toutputBytes[i] = Number(temp & 0xffn);\n\t\ttemp >>= 8n;\n\t}\n\tconst outputHash = bytesToHex(hashByteArray(outputBytes));\n\t\n\treturn { programHash, outputHash };\n};\n\n/**\n * @param programHash - The BLAKE2s hash of the Cairo program's bytecode.\n * @returns A JSON string representing the Cairo secret.\n */\nexport const createCairoSecret = (programHash: string): string => {\n\tconst newSecret: Secret = [\n\t\t'Cairo',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: programHash,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\n/**\n * Computing the BLAKE2s hash of executable bytecode.\n *\n * @param executableBytecode - An array of strings, each representing a 32-bytes value in\n *   hexadecimal format. Allowing for negative values encoded as '-0x...'.\n * @returns The 32-byte BLAKE2s hash of the input bytecode.\n */\nexport const hashExecutableBytecode = (executableBytecode: string[]): Uint8Array => {\n\tconst WORD_LEN = 32; // bytes per felt\n\tconst bytes = new Uint8Array(executableBytecode.length * WORD_LEN);\n\n\texecutableBytecode.forEach((hex, i) => {\n\t\tconst le = Felt252.fromHex(hex).toBytesLE(WORD_LEN);\n\t\tbytes.set(le, i * WORD_LEN);\n\t});\n\n\treturn hashByteArray(bytes);\n};\n\n/**\n * Computes the BLAKE2s hash of the provided bytes.\n *\n * @param a - The input byte array to hash.\n * @returns The 32-byte BLAKE2s hash of the input.\n */\nexport const hashByteArray = (a: Uint8Array): Uint8Array => {\n\tlet hasher = new BLAKE2s();\n\ta.forEach((byte) => hasher.update(new Uint8Array([byte])));\n\treturn hasher.digest();\n};\n\n/**\n * @param proofs\n * @param executable\n * @param programInputs\n */\nexport const cairoProveProofs = async (\n\tproofs: Proof[],\n\texecutable: string,\n\tprogramInputs: bigint[],\n): Promise<Proof[]> => {\n\tlet time = Date.now();\n\tconsole.log('Executing cairo program...');\n\tconst proverInput = await stwoExecute(executable, ...programInputs);\n\tconsole.log('Execution complete in', Date.now() - time, 'ms');\n\tconst withPedersen = containsPedersenBuiltin(proverInput);\n\ttime = Date.now();\n\tconsole.log('Proving cairo execution...');\n\tconst cairoProof = await stwoProve(proverInput);\n\tconsole.log('Proving complete in', Date.now() - time, 'ms');\n\n\tproofs.forEach((p) => {\n\t\ttry {\n\t\t\tconsole.log('adding cairo witness to proof with amount:', p.amount);\n\t\t\tconst secret = parseSecret(p.secret);\n\t\t\tif (secret[0] !== 'Cairo') {\n\t\t\t\tthrow new Error('not a Cairo secret');\n\t\t\t}\n\t\t\tconst cairoWitness: CairoWitness = {\n\t\t\t\tcairo_proof_json: cairoProof,\n\t\t\t\twith_pedersen: withPedersen,\n\t\t\t\twith_bootloader: false,\n\t\t\t};\n\t\t\tp.witness = JSON.stringify(cairoWitness);\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to attach Cairo witness:', e);\n\t\t\tthrow e;\n\t\t}\n\t});\n\n\treturn proofs;\n};\n"],"names":["P","Felt252","v","word","neg","n","x","len","out","i","createCairoDataPayload","cairoExecutable","cairoExpectedOutput","bytecode","programHash","bytesToHex","hashExecutableBytecode","outputBigInt","outputBytes","temp","outputHash","hashByteArray","createCairoSecret","newSecret","randomBytes","executableBytecode","bytes","hex","le","a","hasher","BLAKE2s","byte","cairoProveProofs","proofs","executable","programInputs","time","proverInput","stwoExecute","withPedersen","containsPedersenBuiltin","cairoProof","stwoProve","p","parseSecret","cairoWitness","e"],"mappings":"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"}