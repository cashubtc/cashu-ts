"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("@noble/curves/abstract/utils"),m=require("@noble/hashes/utils"),p=require("@noble/hashes/blake2"),x=require("../common/NUT10.cjs.js"),u=require("stwo-cairo"),y=(1n<<251n)+17n*(1n<<192n)+1n;class g{constructor(t){this.v=t}static fromHex(t){let o=t.startsWith("-");o&&(t=t.slice(1));let e=BigInt(t);o&&(e=-e);const r=(e%y+y)%y;return new g(r)}toBytesLE(t=32){const o=new Uint8Array(t);let e=this.v;for(let r=0;r<t;r++)o[r]=Number(e&0xffn),e>>=8n;return o}}const b=(n,t)=>{const e=JSON.parse(n).program.bytecode,r=h.bytesToHex(f(e)),a=BigInt(t),l=new Uint8Array(32);let s=a;for(let i=0;i<32;i++)l[i]=Number(s&0xffn),s>>=8n;const c=h.bytesToHex(w(l));return{programHash:r,outputHash:c}},d=n=>{const t=["Cairo",{nonce:h.bytesToHex(m.randomBytes(32)),data:n}];return JSON.stringify(t)},f=n=>{const o=new Uint8Array(n.length*32);return n.forEach((e,r)=>{const a=g.fromHex(e).toBytesLE(32);o.set(a,r*32)}),w(o)},w=n=>{let t=new p.BLAKE2s;return n.forEach(o=>t.update(new Uint8Array([o]))),t.digest()},E=async(n,t,o)=>{console.log("Initializing cairo wasm workers..."),u.init(),console.log("Initialization complete.");let e=Date.now();console.log("Executing cairo program...");const r=await u.execute(t,...o);console.log("Execution complete in",Date.now()-e,"ms");const a=u.containsPedersenBuiltin(r);e=Date.now(),console.log("Proving cairo execution...");const l=await u.prove(r);return console.log("Proving complete in",Date.now()-e,"ms"),n.forEach(s=>{try{if(console.log("adding cairo witness to proof with amount:",s.amount),x.parseSecret(s.secret)[0]!=="Cairo")throw new Error("not a Cairo secret");const i={cairo_proof_json:l,with_pedersen:a,with_bootloader:!1};s.witness=JSON.stringify(i)}catch(c){throw console.error("Failed to attach Cairo witness:",c),c}}),n};exports.cairoProveProofs=E;exports.createCairoDataPayload=b;exports.createCairoSecret=d;exports.hashByteArray=w;exports.hashExecutableBytecode=f;
//# sourceMappingURL=NUTXX.cjs.js.map
