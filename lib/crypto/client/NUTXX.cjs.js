"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("@noble/curves/abstract/utils"),m=require("@noble/hashes/utils"),p=require("@noble/hashes/blake2"),x=require("../common/NUT10.cjs.js"),u=require("stwo-cairo"),y=(1n<<251n)+17n*(1n<<192n)+1n;class f{constructor(t){this.v=t}static fromHex(t){let o=t.startsWith("-");o&&(t=t.slice(1));let e=BigInt(t);o&&(e=-e);const r=(e%y+y)%y;return new f(r)}toBytesLE(t=32){const o=new Uint8Array(t);let e=this.v;for(let r=0;r<t;r++)o[r]=Number(e&0xffn),e>>=8n;return o}}const b=(n,t)=>{const e=JSON.parse(n).program.bytecode,r=h.bytesToHex(w(e)),c=BigInt(t),l=new Uint8Array(32);let s=c;for(let i=0;i<32;i++)l[i]=Number(s&0xffn),s>>=8n;const a=h.bytesToHex(g(l));return{programHash:r,outputHash:a}},d=n=>{const t=["Cairo",{nonce:h.bytesToHex(m.randomBytes(32)),data:n}];return JSON.stringify(t)},w=n=>{const o=new Uint8Array(n.length*32);return n.forEach((e,r)=>{const c=f.fromHex(e).toBytesLE(32);o.set(c,r*32)}),g(o)},g=n=>{let t=new p.BLAKE2s;return n.forEach(o=>t.update(new Uint8Array([o]))),t.digest()},E=async(n,t,o)=>{let e=Date.now();console.log("Executing cairo program...");const r=await u.execute(t,...o);console.log("Execution complete in",Date.now()-e,"ms");const c=u.containsPedersenBuiltin(r);e=Date.now(),console.log("Proving cairo execution...");const l=await u.prove(r);return console.log("Proving complete in",Date.now()-e,"ms"),n.forEach(s=>{try{if(console.log("adding cairo witness to proof with amount:",s.amount),x.parseSecret(s.secret)[0]!=="Cairo")throw new Error("not a Cairo secret");const i={cairo_proof_json:l,with_pedersen:c,with_bootloader:!1};s.witness=JSON.stringify(i)}catch(a){throw console.error("Failed to attach Cairo witness:",a),a}}),n};exports.cairoProveProofs=E;exports.createCairoDataPayload=b;exports.createCairoSecret=d;exports.hashByteArray=g;exports.hashExecutableBytecode=w;
//# sourceMappingURL=NUTXX.cjs.js.map
