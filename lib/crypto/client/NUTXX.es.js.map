{"version":3,"file":"NUTXX.es.js","sources":["../../../src/crypto/client/NUTXX.ts"],"sourcesContent":["import { bytesToHex } from '@noble/curves/abstract/utils';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { BLAKE2s } from '@noble/hashes/blake2';\nimport { type CairoWitness, type Proof } from '../../model/types/index';\nimport { type Secret } from '../common/index';\nimport { parseSecret } from '../common/NUT10';\nimport {\n\tinit,\n\texecute as stwoExecute,\n\tprove as stwoProve,\n\tcontainsPedersenBuiltin,\n} from 'stwo-cairo';\n\n/**\n * Order of the prime field.\n */\nconst P = (1n << 251n) + 17n * (1n << 192n) + 1n;\n\n/**\n * Minimal implementation of a Felt252 type, no operations supported.\n *\n * @link https://www.starknet.io/cairo-book/ch02-02-data-types.html#felt-type\n */\nclass Felt252 {\n\tprivate constructor(private readonly v: bigint) {}\n\n\tstatic fromHex(word: string): Felt252 {\n\t\t// handling -0x.. case\n\t\tlet neg = word.startsWith('-');\n\t\tif (neg) word = word.slice(1);\n\n\t\tlet n = BigInt(word);\n\t\tif (neg) n = -n;\n\n\t\tconst x = ((n % P) + P) % P;\n\t\treturn new Felt252(x);\n\t}\n\n\t// 32-byte little-endian\n\ttoBytesLE(len = 32): Uint8Array {\n\t\tconst out = new Uint8Array(len);\n\t\tlet x = this.v;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tout[i] = Number(x & 0xffn);\n\t\t\tx >>= 8n;\n\t\t}\n\t\treturn out;\n\t}\n}\n\n/**\n * Helper function to create cairoSend object from executable and expected output.\n * \n * @param cairoExecutable - JSON string representing the Cairo executable\n * @param cairoExpectedOutput - Expected output as a number or bigint\n * @returns Object with programHash and outputHash for use in wallet.send\n */\nexport const createCairoDataPayload = (\n\tcairoExecutable: string,\n\tcairoExpectedOutput: number | bigint\n): { programHash: string; outputHash: string } => {\n\tconst executable = JSON.parse(cairoExecutable);\n\tconst bytecode = executable.program.bytecode;\n\tconst programHash = bytesToHex(hashExecutableBytecode(bytecode));\n\tconst outputBigInt = BigInt(cairoExpectedOutput);\n\tconst outputBytes = new Uint8Array(32);\n\tlet temp = outputBigInt;\n\n\tfor (let i = 0; i < 32; i++) {\n\t\toutputBytes[i] = Number(temp & 0xffn);\n\t\ttemp >>= 8n;\n\t}\n\tconst outputHash = bytesToHex(hashByteArray(outputBytes));\n\t\n\treturn { programHash, outputHash };\n};\n\n/**\n * @param programHash - The BLAKE2s hash of the Cairo program's bytecode.\n * @returns A JSON string representing the Cairo secret.\n */\nexport const createCairoSecret = (programHash: string): string => {\n\tconst newSecret: Secret = [\n\t\t'Cairo',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: programHash,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\n/**\n * Computing the BLAKE2s hash of executable bytecode.\n *\n * @param executableBytecode - An array of strings, each representing a 32-bytes value in\n *   hexadecimal format. Allowing for negative values encoded as '-0x...'.\n * @returns The 32-byte BLAKE2s hash of the input bytecode.\n */\nexport const hashExecutableBytecode = (executableBytecode: string[]): Uint8Array => {\n\tconst WORD_LEN = 32; // bytes per felt\n\tconst bytes = new Uint8Array(executableBytecode.length * WORD_LEN);\n\n\texecutableBytecode.forEach((hex, i) => {\n\t\tconst le = Felt252.fromHex(hex).toBytesLE(WORD_LEN);\n\t\tbytes.set(le, i * WORD_LEN);\n\t});\n\n\treturn hashByteArray(bytes);\n};\n\n/**\n * Computes the BLAKE2s hash of the provided bytes.\n *\n * @param a - The input byte array to hash.\n * @returns The 32-byte BLAKE2s hash of the input.\n */\nexport const hashByteArray = (a: Uint8Array): Uint8Array => {\n\tlet hasher = new BLAKE2s();\n\ta.forEach((byte) => hasher.update(new Uint8Array([byte])));\n\treturn hasher.digest();\n};\n\n/**\n * @param proofs\n * @param executable\n * @param programInputs\n */\nexport const cairoProveProofs = async (\n\tproofs: Proof[],\n\texecutable: string,\n\tprogramInputs: bigint[],\n): Promise<Proof[]> => {\n\tlet time = Date.now();\n\tconsole.log('Executing cairo program...');\n\tconst proverInput = await stwoExecute(executable, ...programInputs);\n\tconsole.log('Execution complete in', Date.now() - time, 'ms');\n\tconst withPedersen = containsPedersenBuiltin(proverInput);\n\ttime = Date.now();\n\tconsole.log('Proving cairo execution...');\n\tconst cairoProof = await stwoProve(proverInput);\n\tconsole.log('Proving complete in', Date.now() - time, 'ms');\n\n\tproofs.forEach((p) => {\n\t\ttry {\n\t\t\tconsole.log('adding cairo witness to proof with amount:', p.amount);\n\t\t\tconst secret = parseSecret(p.secret);\n\t\t\tif (secret[0] !== 'Cairo') {\n\t\t\t\tthrow new Error('not a Cairo secret');\n\t\t\t}\n\t\t\tconst cairoWitness: CairoWitness = {\n\t\t\t\tcairo_proof_json: cairoProof,\n\t\t\t\twith_pedersen: withPedersen,\n\t\t\t\twith_bootloader: false,\n\t\t\t};\n\t\t\tp.witness = JSON.stringify(cairoWitness);\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to attach Cairo witness:', e);\n\t\t\tthrow e;\n\t\t}\n\t});\n\n\treturn proofs;\n};\n"],"names":["P","Felt252","v","word","neg","n","x","len","out","i","createCairoDataPayload","cairoExecutable","cairoExpectedOutput","bytecode","programHash","bytesToHex","hashExecutableBytecode","outputBigInt","outputBytes","temp","outputHash","hashByteArray","createCairoSecret","newSecret","randomBytes","executableBytecode","bytes","hex","le","a","hasher","BLAKE2s","byte","cairoProveProofs","proofs","executable","programInputs","time","proverInput","stwoExecute","withPedersen","containsPedersenBuiltin","cairoProof","stwoProve","p","parseSecret","cairoWitness","e"],"mappings":"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"}