{"version":3,"file":"mint.es.js","sources":["../../src/crypto/mint/index.ts"],"sourcesContent":["import { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils';\nimport {\n\ttype BlindSignature,\n\ttype IntRange,\n\ttype Keyset,\n\ttype MintKeys,\n\ttype Proof,\n\tcreateRandomPrivateKey,\n\tderiveKeysetId,\n\thashToCurve,\n} from '../common/index';\nimport { HDKey } from '@scure/bip32';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: MintKeys;\n\tprivKeys: MintKeys;\n};\n\nexport type KeysetWithKeys = Keyset & {\n\tpubKeys: MintKeys;\n};\n\nexport function createBlindSignature(\n\tB_: ProjPointType<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst C_: ProjPointType<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: MintKeys = {};\n\tconst privKeys: MintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomPrivateKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(pubKeys);\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: Proof, privKey: Uint8Array): boolean {\n\tconst Y: ProjPointType<bigint> = hashToCurve(proof.secret);\n\tconst aY: ProjPointType<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n"],"names":["DERIVATION_PATH","createBlindSignature","B_","privateKey","amount","id","bytesToNumber","getPubKeyFromPrivKey","privKey","secp256k1","createNewMintKeys","pow2height","seed","counter","pubKeys","privKeys","masterKey","HDKey","index","k","createRandomPrivateKey","keysetId","deriveKeysetId","verifyProof","proof","hashToCurve"],"mappings":";;;;AAeA,MAAMA,IAAkB;AAYjB,SAASC,EACfC,GACAC,GACAC,GACAC,GACiB;AAEjB,SAAO,EAAE,IADyBH,EAAG,SAASI,EAAcH,CAAU,CAAC,GAC1D,QAAAC,GAAQ,IAAAC,EAAA;AACtB;AAEO,SAASE,EAAqBC,GAAqB;AACzD,SAAOC,EAAU,aAAaD,GAAS,EAAI;AAC5C;AAEO,SAASE,EAAkBC,GAA6BC,GAA+B;AAC7F,MAAIC,IAAU;AACd,QAAMC,IAAoB,CAAA,GACpBC,IAAqB,CAAA;AAC3B,MAAIC;AAIJ,OAHIJ,MACHI,IAAYC,EAAM,eAAeL,CAAI,IAE/BC,IAAUF,KAAY;AAC5B,UAAMO,KAAiB,MAAML,GAAS,SAAA;AACtC,QAAIG,GAAW;AACd,YAAMG,IAAIH,EAAU,OAAO,GAAGhB,CAAe,IAAIa,CAAO,EAAE,EAAE;AAC5D,UAAIM;AACH,QAAAJ,EAASG,CAAK,IAAIC;AAAA;AAElB,cAAM,IAAI,MAAM,sCAAsCnB,CAAe,IAAIa,CAAO,EAAE;AAAA,IAEpF;AACC,MAAAE,EAASG,CAAK,IAAIE,EAAA;AAGnB,IAAAN,EAAQI,CAAK,IAAIX,EAAqBQ,EAASG,CAAK,CAAC,GACrDL;AAAA,EACD;AACA,QAAMQ,IAAWC,EAAeR,CAAO;AACvC,SAAO,EAAE,SAAAA,GAAS,UAAAC,GAAU,UAAAM,EAAA;AAC7B;AAEO,SAASE,EAAYC,GAAchB,GAA8B;AAGvE,SAFiCiB,EAAYD,EAAM,MAAM,EACrB,SAASlB,EAAcE,CAAO,CAAC,EACzD,OAAOgB,EAAM,CAAC;AACzB;"}