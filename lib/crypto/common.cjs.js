"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("@noble/curves/secp256k1"),u=require("@noble/hashes/sha256"),s=require("@noble/curves/abstract/utils"),f=require("./util.cjs.js"),a=require("buffer"),l=s.hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");function x(e){const t=u.sha256(a.Buffer.concat([l,e])),n=new Uint32Array(1),i=2**16;for(let o=0;o<i;o++){const y=new Uint8Array(n.buffer),r=u.sha256(a.Buffer.concat([t,y]));try{return m(s.bytesToHex(a.Buffer.concat([new Uint8Array([2]),r])))}catch{n[0]++}}throw new Error("No valid point found")}function g(e){const n=e.map(o=>o.toHex(!1)).join("");return u.sha256(new TextEncoder().encode(n))}function T(e){return h.secp256k1.ProjectivePoint.fromHex(s.bytesToHex(e))}function m(e){return h.secp256k1.ProjectivePoint.fromHex(e)}const B=e=>{let t;return/^[a-fA-F0-9]+$/.test(e)?t=f.hexToNumber(e)%BigInt(2**31-1):t=f.bytesToNumber(f.encodeBase64toUint8(e))%BigInt(2**31-1),t};function I(){return h.secp256k1.utils.randomPrivateKey()}function d(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s.bytesToHex(e[n])}),t}function b(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s.hexToBytes(e[n])}),t}function p(e){const n=r=>[BigInt(r[0]),r[1]],i=Object.entries(d(e)).map(n).sort((r,c)=>r[0]<c[0]?-1:r[0]>c[0]?1:0).map(([,r])=>s.hexToBytes(r)).reduce((r,c)=>K(r,c),new Uint8Array),o=u.sha256(i);return"00"+a.Buffer.from(o).toString("hex").slice(0,14)}function K(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n}exports.createRandomPrivateKey=I;exports.deriveKeysetId=p;exports.deserializeMintKeys=b;exports.getKeysetIdInt=B;exports.hashToCurve=x;exports.hash_e=g;exports.pointFromBytes=T;exports.pointFromHex=m;exports.serializeMintKeys=d;
//# sourceMappingURL=common.cjs.js.map
