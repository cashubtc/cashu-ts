{"version":3,"file":"mint.cjs.js","sources":["../../src/crypto/mint/index.ts"],"sourcesContent":["import { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils';\nimport {\n\ttype BlindSignature,\n\ttype IntRange,\n\ttype Keyset,\n\ttype MintKeys,\n\ttype Proof,\n\tcreateRandomPrivateKey,\n\tderiveKeysetId,\n\thashToCurve,\n} from '../common/index';\nimport { HDKey } from '@scure/bip32';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: MintKeys;\n\tprivKeys: MintKeys;\n};\n\nexport type KeysetWithKeys = Keyset & {\n\tpubKeys: MintKeys;\n};\n\nexport function createBlindSignature(\n\tB_: ProjPointType<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst C_: ProjPointType<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: MintKeys = {};\n\tconst privKeys: MintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomPrivateKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(pubKeys);\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: Proof, privKey: Uint8Array): boolean {\n\tconst Y: ProjPointType<bigint> = hashToCurve(proof.secret);\n\tconst aY: ProjPointType<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n"],"names":["DERIVATION_PATH","createBlindSignature","B_","privateKey","amount","id","bytesToNumber","getPubKeyFromPrivKey","privKey","secp256k1","createNewMintKeys","pow2height","seed","counter","pubKeys","privKeys","masterKey","HDKey","index","k","createRandomPrivateKey","keysetId","deriveKeysetId","verifyProof","proof","hashToCurve"],"mappings":"6MAeMA,EAAkB,aAYjB,SAASC,EACfC,EACAC,EACAC,EACAC,EACiB,CAEjB,MAAO,CAAE,GADyBH,EAAG,SAASI,EAAAA,cAAcH,CAAU,CAAC,EAC1D,OAAAC,EAAQ,GAAAC,CAAA,CACtB,CAEO,SAASE,EAAqBC,EAAqB,CACzD,OAAOC,YAAU,aAAaD,EAAS,EAAI,CAC5C,CAEO,SAASE,EAAkBC,EAA6BC,EAA+B,CAC7F,IAAIC,EAAU,GACd,MAAMC,EAAoB,CAAA,EACpBC,EAAqB,CAAA,EAC3B,IAAIC,EAIJ,IAHIJ,IACHI,EAAYC,EAAAA,MAAM,eAAeL,CAAI,GAE/BC,EAAUF,GAAY,CAC5B,MAAMO,GAAiB,IAAML,GAAS,SAAA,EACtC,GAAIG,EAAW,CACd,MAAMG,EAAIH,EAAU,OAAO,GAAGhB,CAAe,IAAIa,CAAO,EAAE,EAAE,WAC5D,GAAIM,EACHJ,EAASG,CAAK,EAAIC,MAElB,OAAM,IAAI,MAAM,sCAAsCnB,CAAe,IAAIa,CAAO,EAAE,CAEpF,MACCE,EAASG,CAAK,EAAIE,yBAAA,EAGnBN,EAAQI,CAAK,EAAIX,EAAqBQ,EAASG,CAAK,CAAC,EACrDL,GACD,CACA,MAAMQ,EAAWC,EAAAA,eAAeR,CAAO,EACvC,MAAO,CAAE,QAAAA,EAAS,SAAAC,EAAU,SAAAM,CAAA,CAC7B,CAEO,SAASE,EAAYC,EAAchB,EAA8B,CAGvE,OAFiCiB,EAAAA,YAAYD,EAAM,MAAM,EACrB,SAASlB,EAAAA,cAAcE,CAAO,CAAC,EACzD,OAAOgB,EAAM,CAAC,CACzB"}